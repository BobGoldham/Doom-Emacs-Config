# SPDX-FileCopyrightText Â© 2023 BobGoldham <sold@sold.rip>
# SPDX-License-Identifier MIT
#+title: Doom Emacs Configuration
#+subtitle: Tecosaur was right..
#+author: Bob Goldham
#+email: sold@sold.rip
#+date: @@html:<!--@@{{{git-rev}}}@@html:-->@@@@latex:\\\Large\bfseries@@ {{{modification-time(%Y-%m-%d, t)}}} @@latex:\\\normalsize\mdseries@@{{{modification-time(%H:%M, t)}}} @@latex:\acr{\lowercase{@@{{{timezone}}}@@latex:}}\iffalse@@, {{{git-rev}}}@@latex:\fi@@
#+macro: timezone (eval (substring (shell-command-to-string "date +%Z") 0 -1))
#+macro: git-rev (eval (format "@@html:<a href=\"https://github.com/BobGoldham/Doom-Emacs-Config/commit/%1$s\" style=\"text-decoration: none\"><code style=\"padding: 0; color: var(--text-light); font-size: inherit; opacity: 0.7\">%1$s</code></a>@@@@latex:\\href{https://github.com/BobGoldham/Doom-Emacs-Config/commit/%1$s}{\\normalsize\\texttt{%1$s}}@@" (substring (shell-command-to-string "git rev-parse --short HEAD") 0 -1)))
#+html_head: <link rel='shortcut icon' type='image/png' href='https://www.gnu.org/software/emacs/favicon.png'>
#+property: header-args:emacs-lisp
#+property: header-args:elisp :results replace :exports code
#+property: header-args:shell :tangle "setup.sh"
#+property: header-args :tangle no :results silent :eval no-export
#+embed: LICENCE :description MIT licence file
#+options: coverpage:yes
#+startup: unfold

#+latex_class: chameleon
#+latex_header_extra: \usepackage[autooneside=false,automark,headsepline]{scrlayer-scrpage}
#+latex_header_extra: \clearpairofpagestyles \renewcommand*{\chaptermarkformat}{} \renewcommand*{\sectionmarkformat}{}
#+latex_header_extra: \ihead{\upshape\scshape\leftmark} \chead{\Ifstr{\leftmark}{\rightmark}{}{\rightmark}} \ohead[\pagemark]{\pagemark}
#+latex_engraved_theme: doom-one-light

#+begin_export html
<a href="https://github.com/BobGoldham/DoomEmacsConfig"
style="font-family: 'Open Sans'; background-image: none; color: inherit;
          text-decoration: none; position: relative; top: clamp(-26px, calc(1280px - 100vw), 0px); opacity: 0.7;">
<img src="https://git-scm.com/images/logos/downloads/Git-Icon-Black.svg"
class="invertible" alt="Git"
style="height: 1em; position: relative; top: 0.1em;">
Repository</a>&ensp;
#+end_export

#+begin_quote
Let us change our traditional attitude to the construction of programs:
Instead of imagining that our main task is to instruct a computer what to do,
let us concentrate rather on explaining to human beings what we want a
computer to do. @@latex:\mbox{@@--- Donald Knuth@@latex:}@@
#+end_quote

* The Basics
** Confpkg
*** Disclaimer
This is an extremely useful snippet of configuration made by [[https://tecosaur.github.io/emacs-config/config.html][tecosaur]],
and as such I have decided to /shamelessly steal it/.
All credit for the "Confpkg" system is with tecosaur.

*** Preparation

This approach is built around =#+call= invocations that affect the tangling.
Unfortunately for this use-case, babel call keywords are not executed on tangle.
Tangled noweb blocks /are/ however, and so we can fudge the behaviour we want by
tangling a noweb block to a temp file, with a noweb block that executes babel
calls in the buffer.

#+name: confpkg-prepare
#+begin_src emacs-lisp :noweb no-export
(condition-case nil
    (progn
      (message "Intitialising confpkg")
      <<bootstrap>>
      (org-fold-core-ignore-fragility-checks
        (org-babel-map-executables nil
          (when (eq (org-element-type (org-element-context)) 'babel-call)
            (org-babel-lob-execute-maybe)))))
  (quit (revert-buffer t t t)))
#+end_src

See the [[Bootstrap]] section for an explanation of the =<<bootstrap>>= noweb reference.

#+header: :tangle (expand-file-name (make-temp-name "emacs-org-babel-excuses/confpkg-prepare-") temporary-file-directory)
#+begin_src emacs-lisp :noweb no-export :mkdirp yes :export-embed no
<<confpkg-prepare()>>
#+end_src

*** Setup

Before generating the template with babel, we want to keep track of:
+ How many config groups are created
+ Information about each config group

To do this we can simply create two variables. Due to temp-buffer shenanigans,
we'll have to use global variables here.

Then we need to set up the two final phases of this process:
+ Creating =config.el=
+ Cleaning up the superfluous generated content

To trigger the final phases we'll add a hook to ~org-babel-post-tangle-hook~. Once
again, it would be preferred if this was done locally, but it needs to be
global. To avoid this causing headaches down the line we'll make sure when
implementing the hook function to have it remove itself from the hook when
executed.

#+name: confpkg-setup
#+begin_src emacs-lisp :results silent :noweb no-export
(setq confpkg--num 0
      confpkg--list nil)

<<confpkg-dependency-analysis>>
<<confpkg-strip-package-statements>>
<<confpkg-create-config>>
(defun confpkg-cleanup ()
  <<confpkg-cleanup>>
  )
<<confpkg-finaliser>>

<<confpkg-clear-old-files>>

(add-hook 'org-babel-tangle-finished-hook #'confpkg-tangle-finalise)
#+end_src

To avoid generating cruft, it would also be good to get rid of old tangled
config files at the start.

#+name: confpkg-clear-old-files
#+begin_src emacs-lisp
(make-directory "subconf" t)
(dolist (conf-file (directory-files "subconf" t "config-.*\\.el"))
  (delete-file conf-file))
#+end_src

Now to have this take effect, we can just use a babel call keyword. Thanks to
the preparation step this will be executed during tangling.

#+call: confpkg-setup[:results none]()

*** Package generation

Now we actually implement the =confpkg= babel function. We could just direct the
output into the =subconf/config-X.el= file without any extra steps, but why not be
a bit fancier and make it more like a package.

To do this, we'll have =confpkg= load a template and then fill it in using
~format-spec~. To make sure this is actually used, we'll call ~org-set-property~ to
modify the parent heading, and register the config group with the variables we
created earlier.

#+name: confpkg
#+begin_src elisp :var name="" needs="" after="" pre="" prefix="config-" via="copy" :results silent raw :noweb no-export
;; Babel block for use with #+call
;; Arguments:
;;  - name, the name of the config sub-package
;;  - needs, (when non-empty) required system executable(s)
;;  - after, required features
;;  - pre, a noweb reference to code that should be executed eagerly,
;;    and not deferred via after. The code is not included in the
;;    generated .el file and should only be used in dire situations.
;;  - prefix, the package prefix ("config-" by default)
;;  - via, how this configuration should be included in config.el,
;;    the current options are:
;;    + "copy", copy the configuration lisp
;;    + "require", insert a require statement
;;    + "none", do not do anything to load this configuration.
;;      This only makes sense when configuration is either being
;;      temporarily disabled or loaded indirectly/elsewhere.
(when (or (string-empty-p needs)
          (cl-every #'executable-find (delq nil (split-string needs ","))))
  (let* ((name (if (string-empty-p name)
                   (save-excursion
                     (and (org-back-to-heading-or-point-min t)
                          (substring-no-properties
                           (org-element-interpret-data
                            (org-element-property :title (org-element-at-point))))))
                 name))
         (after
          (cond
           ((string-empty-p after) nil)
           ((string-match-p "\\`[^()]+\\'" after)
            (intern after)) ; Single feature.
           (t after)))
         (pre (and (not (string-empty-p pre)) pre))
         (confpkg-name
          (concat prefix (replace-regexp-in-string
                          "[^a-z-]" "-" (downcase name))))
         (confpkg-file (expand-file-name (concat confpkg-name ".el")
                                         "subconf")))
    (unless (file-exists-p confpkg-file)
      (make-empty-file confpkg-file t))
    (cl-incf confpkg--num)
    (org-set-property
     "header-args:emacs-lisp"
     (format ":tangle no :noweb-ref %s" confpkg-name))
    (push (list :name name
                :package confpkg-name
                :file confpkg-file
                :after after
                :pre pre
                :via (intern via)
                :package-statements nil)
          confpkg--list)
    (format-spec
     "#+begin_src emacs-lisp :tangle %f :mkdirp yes :noweb no-export :noweb-ref none :comments no
<<confpkg-template>>
,#+end_src"
     `((?n . ,confpkg--num)
       (?p . ,confpkg-name)
       (?f . ,confpkg-file)
       (?Y . ,(format-time-string "%Y"))
       (?B . ,(format-time-string "%B"))
       (?m . ,(format-time-string "%m"))
       (?d . ,(format-time-string "%d"))
       (?M . ,(format-time-string "%M"))
       (?S . ,(format-time-string "%S"))))))
#+end_src

Now all that's needed is a template to be used.

#+name: confpkg-template
#+begin_src emacs-lisp :eval no
;;; %p.el --- Generated package (no.%n) from my config -*- lexical-binding: t; -*-
;;
;; Copyright (C) %Y BobGoldham
;;
;; Author: Bob Goldham
;; Maintainer: Bob Goldham <sold@sold.rip>
;; Created: %B %d, %Y
;; Modified: %B %d, %Y
;; Version: %Y.%m.%d
;; Homepage: https://github.com/BobGoldham/Doom-Emacs-Config
;; Package-Requires: ((emacs \"27.1\"))
;;
;; This file is not part of GNU Emacs.
;;
;;; Commentary:
;;
;;  Generated package (no.%n) from my config.
;;
;;  This is liable to have unstated dependencies, and reply on other bits of
;;  state from other configuration blocks. Only use this if you know /exactly/
;;  what you are doing.
;;
;;  This may function nicely as a bit of self-contained functionality, or it
;;  might be a horrid mix of functionalities and state.
;;
;;  Hopefully, in future static analysis will allow this to become more
;;  properly package-like.
;;
;;; Code:

<<%p>>

(provide '%p)
;;; %p.el ends here
#+end_src

This currently makes the included content look much more package-like that in
truly is. However, I hope that some static analysis in future will allow for
dependency information to be collected and included.

Lastly, should there be an issue or interruption, it's possible that the
modifications from =#+call: confpkg= may persist. If I've been good with my
committing, resolving this should be as simple as reverting unstaged changes.
So... back in reality, it would be nice to have a way to clean up =confpkg=
residue.

#+name: confpkg-cleanup
#+begin_src emacs-lisp :results none
(org-fold-core-ignore-fragility-checks
  (org-babel-map-executables nil
    (when (and (eq (org-element-type (org-element-context)) 'babel-call)
               (equal (org-element-property :call (org-element-context)) "confpkg"))
      (org-babel-remove-result)
      (org-entry-delete nil "header-args:emacs-lisp"))))
#+end_src

*** Identify cross-package dependencies
:PROPERTIES:
:header-args:emacs-lisp: :noweb-ref confpkg-dependency-analysis
:END:

At a basic level, we can search for regexp expressions indicating the definition
of functions or variables and search for their usage.

#+begin_src emacs-lisp
(defun confpkg--rough-extract-definitions (file)
  (with-temp-buffer
    (insert-file-contents file)
    (goto-char (point-min))
    (let (symbols)
      (while (re-search-forward
              (rx line-start (* (any ?\s ?\t)) "("
                  (or "defun" "defmacro" "defsubst" "defgeneric" "defalias" "defvar" "defcustom" "defface" "deftheme"
                      "cl-defun" "cl-defmacro" "cl-defsubst" "cl-defmethod" "cl-defstruct" "cl-defgeneric" "cl-deftype")
                  (+ (any ?\s ?\t))
                  (group (+ (any "A-Z" "a-z" "0-9"
                                 ?+ ?- ?* ?/ ?_ ?~ ?! ?@ ?$ ?% ?^ ?& ?= ?: ?< ?> ?{ ?})))
                  (or blank ?\n))
              nil t)
        (push (match-string 1) symbols))
      symbols)))
#+end_src

Continuing our rough regexp approach, we can construct a similar function to
look for uses of symbols.

#+begin_src emacs-lisp
(defun confpkg--rough-uses-p (file symbols)
  (with-temp-buffer
    (insert-file-contents file)
    (let ((symbols (copy-sequence symbols)) uses-p)
      (while symbols
        (goto-char (point-min))
        (if (re-search-forward (rx word-start (literal (car symbols)) word-end) nil t)
            (setq uses-p t symbols nil)
          (setq symbols (cdr symbols))))
      uses-p)))
#+end_src

Now we can put these two functions together to annotate ~confpkg--list~ with their
(confpkg) dependencies.

#+begin_src emacs-lisp
(defun confpkg-annotate-list-dependencies ()
  (dolist (confpkg confpkg--list)
    (plist-put confpkg :defines
               (confpkg--rough-extract-definitions
                (plist-get confpkg :file))))
  (dolist (confpkg confpkg--list)
    (let ((after (plist-get confpkg :after))
          requires)
      (dolist (other-confpkg confpkg--list)
        (when (and (not (eq other-confpkg confpkg))
                   (confpkg--rough-uses-p (plist-get confpkg :file)
                                          (plist-get other-confpkg :defines)))
          (push (plist-get other-confpkg :package) requires)))
      (when (and after (symbolp after))
        (push after requires))
      (plist-put confpkg :requires requires))))
#+end_src

Finally, we can use this information to edit the confpkg files to add the
necessary ~require~ statements.

#+begin_src emacs-lisp
(defun confpkg-write-dependencies ()
  (dolist (confpkg confpkg--list)
    (when (plist-get confpkg :requires)
      (with-temp-buffer
        (setq buffer-file-name (plist-get confpkg :file))
        (insert-file-contents buffer-file-name)
        (re-search-forward "^;;; Code:\n")
        (insert "\n")
        (dolist (req (plist-get confpkg :requires))
          (insert (format "(require '%s)\n" req)))
        (write-region nil nil buffer-file-name)
        (set-buffer-modified-p nil)))))
#+end_src

*** Commenting out ~package!~ statements

It's easy enough to set ~package!~ statements to tangle to =packages.el=, however
with our noweb ref approach they will /also/ go to the config files. This could be
viewed as a problem, but I actually think it's rather nice to have the package
information with the config. So, we can look for an immediate ~package!~ statement
and simply comment it out. As a bonus, we can also then record which packages
are needed for each block of config.

#+name: confpkg-strip-package-statements
#+begin_src emacs-lisp
(defun confpkg-comment-out-package-statements ()
  (dolist (confpkg confpkg--list)
    (with-temp-buffer
      (setq buffer-file-name (plist-get confpkg :file))
      (insert-file-contents buffer-file-name)
      (goto-char (point-min))
      (while (re-search-forward "^;;; Code:\n[[:space:]\n]*(\\(package!\\|unpin!\\)[[:space:]\n]+\\([^[:space:]]+\\)\\b" nil t)
        (plist-put confpkg :package-statements
                   (nconc (plist-get confpkg :package-statements)
                          (list (match-string 2))))
        (let* ((start (progn (beginning-of-line) (point)))
               (end (progn (forward-sexp 1)
                           (if (looking-at "[\t ]*;.*")
                               (line-end-position)
                             (point))))
               (contents (buffer-substring start end))
               paste-start paste-end
               (comment-start ";")
               (comment-padding "   ")
               (comment-end ""))
          (delete-region start (1+ end))
          (re-search-backward "^;;; Code:")
          (beginning-of-line)
          (insert ";;  Package statement:\n")
          (setq paste-start (point))
          (insert contents)
          (setq paste-end (point))
          (insert  "\n;;\n")
          (comment-region paste-start paste-end 2)))
      (when (buffer-modified-p)
        (write-region nil nil buffer-file-name)
        (set-buffer-modified-p nil)))))
#+end_src

*** Creating the config file

After all the subconfig files have been tangled, we need to collect their
content and put them together into =config.el=. For this, all that's needed is a
function to go through the registered config groups and put their content in a
tempbuffer. We can call this with the finalising step.

#+name: confpkg-create-config
#+begin_src emacs-lisp
(defun confpkg-create-config ()
  (let ((revert-without-query '("config\\.el"))
        (keywords (org-collect-keywords '("AUTHOR" "EMAIL")))
        (original-buffer (current-buffer)))
    (with-temp-buffer
      (insert
       (format ";;; config.el -*- lexical-binding: t; -*-

;; SPDX-FileCopyrightText: Â© 2020-%s %s <%s>
;; SPDX-License-Identifier: MIT

;; Generated at %s from the literate configuration.

(add-to-list 'load-path %S)\n"
               (format-time-string "%Y")
               (cadr (assoc "AUTHOR" keywords))
               (cadr (assoc "EMAIL" keywords))
               (format-time-string "%FT%T%z")
               (replace-regexp-in-string
                (regexp-quote (getenv "HOME")) "~"
                (expand-file-name "subconf/"))))
      (mapc
       (lambda (confpkg)
         (insert
          (if (eq 'none (plist-get confpkg :via))
              (format "\n;;; %s intentionally omitted.\n" (plist-get confpkg :name))
            (with-temp-buffer
              (cond
               ((eq 'copy (plist-get confpkg :via))
                (insert-file-contents (plist-get confpkg :file))
                (goto-char (point-min))
                (narrow-to-region
                 (re-search-forward "^;;; Code:\n+")
                 (progn
                   (goto-char (point-max))
                   (re-search-backward (format "[^\n\t ][\n\t ]*\n[\t ]*(provide '%s)" (plist-get confpkg :package)))
                   (match-end 0))))
               ((eq 'require (plist-get confpkg :via))
                (insert (format "(require '%s)\n" (plist-get confpkg :package))))
               (t (insert (format "(warn \"%s confpkg :via has unrecognised value: %S\" %S %S)"
                                  (plist-get confpkg :name) (plist-get confpkg :via)))))
              (goto-char (point-min))
              (insert "\n;;:------------------------"
                      "\n;;; " (plist-get confpkg :name)
                      "\n;;:------------------------\n\n")
              (when (plist-get confpkg :defines)
                (insert ";; This block defines "
                        (mapconcat
                         (lambda (d) (format "`%s'" d))
                         (plist-get confpkg :defines)
                         ", ")
                        ".")
                (when (re-search-backward "\\([^, ]+\\), \\([^, ]+\\), \\([^, ]+\\).\\="
                                          (line-beginning-position) t)
                  (replace-match "\\1, \\2, and \\3."))
                (when (re-search-backward "\\([^, ]+\\), \\([^, ]+\\).\\="
                                          (line-beginning-position) t)
                  (replace-match "\\1 and \\2."))
                (insert "\n\n")
                (forward-line -2)
                (setq-local comment-start ";")
                (fill-comment-paragraph)
                (forward-paragraph 1)
                (forward-line 1))
              (if (equal (plist-get confpkg :package) "config-confpkg-timings")
                  (progn
                    (goto-char (point-max))
                    (insert "\n\n\
(confpkg-create-record 'doom-pre-config (float-time (time-subtract (current-time) before-init-time)))
(confpkg-start-record 'config)
(confpkg-create-record 'config-defered 0.0 'config)
(confpkg-create-record 'set-hooks 0.0 'config-defered)
(confpkg-create-record 'load-hooks 0.0 'config-defered)
(confpkg-create-record 'requires 0.0 'root)\n"))
                (let ((after (plist-get confpkg :after))
                      (pre (and (plist-get confpkg :pre)
                                (org-babel-expand-noweb-references
                                 (list "emacs-lisp"
                                       (format "<<%s>>" (plist-get confpkg :pre))
                                       '((:noweb . "yes")
                                         (:comments . "none")))
                                 original-buffer)))
                      (name (replace-regexp-in-string
                             "config--?" ""
                             (plist-get confpkg :package))))
                  (if after
                      (insert (format "(confpkg-with-record '%S\n"
                                      (list (concat "hook: " name) 'set-hooks))
                              (if pre
                                  (concat ";; Begin pre\n" pre "\n;; End pre\n")
                                "")
                              (format (if (symbolp after) ; If single feature.
                                          "  (with-eval-after-load '%s\n"
                                        "  (after! %s\n")
                                      after))
                    (when pre
                      (insert "\n;; Begin pre (unnecesary since after is unused)\n"
                              pre
                              "\n;; End pre\n")))
                  (insert
                   (format "(confpkg-with-record '%S\n"
                           (list (concat "load: " name)
                                 (if after 'load-hooks 'config)))))
                (goto-char (point-max))
                (when (string-match-p ";" (thing-at-point 'line))
                  (insert "\n"))
                (insert ")")
                (when (plist-get confpkg :after)
                  (insert "))"))
                (insert "\n"))
              (buffer-string)))))
       (let ((confpkg-timings ;; Ensure timings is put first.
              (cl-some (lambda (p) (and (equal (plist-get p :package) "config-confpkg-timings") p))
                       confpkg--list)))
         (append (list confpkg-timings)
                 (nreverse (remove confpkg-timings confpkg--list)))))
      (insert "\n(confpkg-finish-record 'config)\n\n;;; config.el ends here")
      (write-region nil nil "config.el" nil :silent))))
#+end_src

Applying lexical binding to the config file is good for a number of reasons,
among which it's (slightly) faster than dynamic binding (see [[https://nullprogram.com/blog/2016/12/22/][this blog post]] for
                                                             more info).

*** Quieter output

All the babel evaluation here ends up being quite noisy (along with a few other
                                                               things during tangle), let's see if we can change that.

#+name: confpkg-quieter-output
#+begin_src emacs-lisp
(when noninteractive
  (unless (fboundp 'doom-shut-up-a)
    (defun doom-shut-up-a (fn &rest args)
      (let ((standard-output #'ignore)
            (inhibit-message t))
        (apply fn args))))
  (advice-add 'org-babel-expand-body:emacs-lisp :around #'doom-shut-up-a)
  ;; Quiet some other annoying messages
  (advice-add 'sh-set-shell :around #'doom-shut-up-a)
  (advice-add 'rng-what-schema :around #'doom-shut-up-a)
  (advice-add 'python-indent-guess-indent-offset :around #'doom-shut-up-a))
#+end_src

#+call: confpkg-quieter-output()

*** Reporting load time information

#+call: confpkg("Confpkg timings")

When generating the config we added a form to collect load-time information.

#+begin_src emacs-lisp
(defvar confpkg-load-time-tree (list (list 'root)))
(defvar confpkg-record-branch (list 'root))
(defvar confpkg-record-num 0)
#+end_src

It would be good to process ~confpkg-load-times~ at the end to make it more
useful, and provide a function to display load time information from it. This is
to aid in identification of confpkgs that take particularly long to load, and
thus would benefit from some attention.

To extract the per-confpkg load times, we can just take the difference in
~(float-time)~ and exclude the first entry.

#+begin_src emacs-lisp
(defun confpkg-create-record (name elapsed &optional parent enclosing)
  (let ((parent (assoc (or parent (car confpkg-record-branch))
                       confpkg-load-time-tree))
        (record (cons name (list (list 'self
                                       :name (format "%s" name)
                                       :num (cl-incf confpkg-record-num)
                                       :elapsed elapsed
                                       :enclosing enclosing)))))
    (push record confpkg-load-time-tree)
    (push record (cdr parent))
    record))

(defun confpkg-start-record (name &optional parent)
  (let ((record (confpkg-create-record name 0.0e+NaN parent t)))
    (plist-put (cdadr record) :start (float-time))
    (push name confpkg-record-branch)
    record))

(defun confpkg-finish-record (name)
  (let ((self-record (cdar (last (cdr (assoc name confpkg-load-time-tree))))))
    (plist-put self-record :elapsed
               (- (float-time) (plist-get self-record :start) 0.0))
    (unless (equal (car confpkg-record-branch) name)
      (message "Warning: Confpkg timing record expected to finish %S, instead found %S. %S"
               name (car confpkg-record-branch) confpkg-record-branch))
    (setq confpkg-record-branch (cdr confpkg-record-branch))))
#+end_src

A convenience macro could be nice to have.

#+begin_src emacs-lisp
(defmacro confpkg-with-record (name &rest body)
  "Create a time record around BODY.
The record must have a NAME."
  (declare (indent 1))
  (let ((name-val (make-symbol "name-val"))
        (record-spec (make-symbol "record-spec")))
    `(let* ((,name-val ,name)
            (,record-spec (if (consp ,name-val) ,name-val (list ,name-val))))
       (apply #'confpkg-start-record ,record-spec)
       (unwind-protect
           (progn ,@body)
         (confpkg-finish-record (car ,record-spec))))))
#+end_src

It would also be nice to collect some other load-time-related information.

#+begin_src emacs-lisp
(defadvice! +require--log-timing-a (orig-fn feature &optional filename noerror)
  :around #'require
  (if (or (featurep feature)
          (eq feature 'cus-start) ; HACK Why!?!
          (assoc (format "require: %s" feature) confpkg-load-time-tree))
      (funcall orig-fn feature filename noerror)
    (confpkg-with-record (list (format "require: %s" feature)
                               (and (eq (car confpkg-record-branch) 'root)
                                    'requires))
      (funcall orig-fn feature filename noerror))))
#+end_src

At last, we'll go to some pains to make a nice result tabulation function.

I will readily admit that this function is absolutely horrible. I just spent an
evening adding to it till it worked then stopped touching it. Maybe in the
future I'll go back to it and try to clean up the implementation.

#+begin_src emacs-lisp
(defun confpkg-timings-report (&optional sort-p node)
  "Display a report on load-time information.
Supply SORT-P (or the universal argument) to sort the results.
NODE defaults to the root node."
  (interactive
   (list (and current-prefix-arg t)))
  (let ((buf (get-buffer-create "*Confpkg Load Time Report*"))
        (depth 0)
        num-pad name-pad max-time max-total-time max-depth)
    (cl-labels
        ((sort-records-by-time
           (record)
           (let ((self (assoc 'self record)))
             (append (list self)
                     (sort (nreverse (remove self (cdr record)))
                           (lambda (a b)
                             (> (or (plist-get (alist-get 'self a) :total) 0.0)
                                (or (plist-get (alist-get 'self b) :total) 0.0)))))))
         (print-record
           (record)
           (cond
            ((eq (car record) 'self)
             (insert
              (propertize
               (string-pad (number-to-string (plist-get (cdr record) :num)) num-pad)
               'face 'font-lock-keyword-face)
              " "
              (propertize
               (apply #'concat
                      (make-list (1- depth) "â¢ "))
               'face 'font-lock-comment-face)
              (string-pad (format "%s" (plist-get (cdr record) :name)) name-pad)
              (make-string (* (- max-depth depth) 2) ?\s)
              (propertize
               (format "%.4fs" (plist-get (cdr record) :elapsed))
               'face
               (list :foreground
                     (doom-blend 'orange 'green
                                 (/ (plist-get (cdr record) :elapsed) max-time))))
              (if (= (plist-get (cdr record) :elapsed)
                     (plist-get (cdr record) :total))
                  ""
                (concat "   (Î£="
                        (propertize
                         (format "%.3fs" (plist-get (cdr record) :total))
                         'face
                         (list :foreground
                               (doom-blend 'orange 'green
                                           (/ (plist-get (cdr record) :total) max-total-time))))
                        ")"))
              "\n"))
            (t
             (cl-incf depth)
             (mapc
              #'print-record
              (if sort-p
                  (sort-records-by-time record)
                (reverse (cdr record))))
             (cl-decf depth))))
         (flatten-records
           (records)
           (if (eq (car records) 'self)
               (list records)
             (mapcan
              #'flatten-records
              (reverse (cdr records)))))
         (tree-depth
           (records &optional depth)
           (if (eq (car records) 'self)
               (or depth 0)
             (1+ (cl-reduce #'max (cdr records) :key #'tree-depth))))
         (mapreduceprop
           (list map reduce prop)
           (cl-reduce
            reduce list
            :key
            (lambda (p) (funcall map (plist-get (cdr p) prop)))))
         (elaborate-timings
           (record)
           (if (eq (car record) 'self)
               (plist-get (cdr record) :elapsed)
             (let ((total (cl-reduce #'+ (cdr record)
                                     :key #'elaborate-timings))
                   (self (cdr (assoc 'self record))))
               (if (plist-get self :enclosing)
                   (prog1
                       (plist-get self :elapsed)
                     (plist-put self :total (plist-get self :elapsed))
                     (plist-put self :elapsed
                                (- (* 2 (plist-get self :elapsed)) total)))
                 (plist-put self :total total)
                 total))))
         (elaborated-timings
           (record)
           (let ((record (copy-tree record)))
             (elaborate-timings record)
             record)))
      (let* ((tree
              (elaborated-timings
               (append '(root)
                       (copy-tree
                        (alist-get (or node 'root)
                                   confpkg-load-time-tree
                                   nil nil #'equal))
                       '((self :num 0 :elapsed 0)))))
             (flat-records
              (cl-remove-if
               (lambda (rec) (= (plist-get (cdr rec) :num) 0))
               (flatten-records tree))))
        (setq max-time (mapreduceprop flat-records #'identity #'max :elapsed)
              max-total-time (mapreduceprop flat-records #'identity #'max :total)
              name-pad (mapreduceprop flat-records #'length #'max :name)
              num-pad (mapreduceprop flat-records
                                     (lambda (n) (length (number-to-string n)))
                                     #'max :num)
              max-depth (tree-depth tree))
        (with-current-buffer buf
          (erase-buffer)
          (setq-local outline-regexp "[0-9]+ *\\(?:â¢ \\)*")
          (outline-minor-mode 1)
          (use-local-map (make-sparse-keymap))
          (local-set-key "TAB" #'outline-toggle-children)
          (local-set-key "\t" #'outline-toggle-children)
          (local-set-key (kbd "<backtab>") #'outline-show-subtree)
          (local-set-key (kbd "C-<iso-lefttab>")
                         (eval `(cmd! (if current-prefix-arg
                                          (outline-show-all)
                                        (outline-hide-sublevels (+ ,num-pad 2))))))
          (insert
           (propertize
            (concat (string-pad "#" num-pad) " "
                    (string-pad "Confpkg"
                                (+ name-pad (* 2 max-depth) -3))
                    (format " Load Time (Î£=%.3fs)\n"
                            (plist-get (cdr (assoc 'self tree)) :total)))
            'face '(:inherit (tab-bar-tab bold) :extend t :underline t)))
          (dolist (record (if sort-p
                              (sort-records-by-time tree)
                            (reverse (cdr tree))))
            (unless (eq (car record) 'self)
              (print-record record)))
          (set-buffer-modified-p nil)
          (goto-char (point-min)))
        (pop-to-buffer buf)))))
#+end_src

*** Finalise

At last, to clean up the content inserted by the babel calls we can just revert
the buffer. As long as ~org-babel-pre-tangle-hook~ hasn't been modified,
~save-buffer~ will be run at the start of the tangle process and so reverting will
take us back to just before the tangle started.

Since this is /the/ function added as the post-tangle hook, we also need to remove
the function from the hook and call the =config.el= creation function.

#+name: confpkg-finaliser
#+begin_src emacs-lisp
(defun confpkg-tangle-finalise ()
  (remove-hook 'org-babel-tangle-finished-hook #'confpkg-tangle-finalise)
  (revert-buffer t t t)
  (confpkg-comment-out-package-statements)
  (confpkg-annotate-list-dependencies)
  (confpkg-create-config)
  (confpkg-write-dependencies)
  (message "Processed %s elisp files" (length confpkg--list)))
#+end_src

Within ~confpkg-tangle-finalise~ we carefully order each step so that
the most important steps go first, to minimise the impact should a particular
step fail.

*** Bootstrap

This system makes use of some recent commits introduced to Org, such as [[https://git.savannah.gnu.org/cgit/emacs/org-mode.git/commit/?id=cb8bf4a0d][this
                                                                                                                                                     noweb expansion bugfix]] which will be included in Org 9.5.4. This is
problematic if using Emacs 28.2 or older, so to get around this we must go
through a bootstrap process.

To start with, we'll check if we are:
+ Running an Org version prior to 9.5.4
+ Running in a ~noninteractive~ session
+ Using an Org that's not installed in the user directory
+ In a session with the symbol ~exit!~ defined

#+name: bootstrap
#+begin_src emacs-lisp :noweb no-export
(let ((required-org-version "9.5.4")
      (standard-output t))
  (when (and (version< (org-version) required-org-version)
             (not (string-match-p (regexp-quote (expand-file-name "~"))
                                  (locate-library "org"))))
    (cond
     ((and noninteractive (fboundp 'exit!))
      (print! (warn (format "Detected conditions provoking a config bootstrap (Org %s)" (org-version))))
      (print! (start "Initiating bootstrap..."))
      <<bootstrap-perform>>
      )
     (t (message "Installed Org version %s is too old, %s is needed.\nRun \"doom sync\" to fix."
                 (org-version) required-org-version)))))
#+end_src

If these conditions are met, we can assume that the loaded Org version is
insufficient, and that it's likely a Emacs is currently running a command like
=doom sync=, and so it makes sense to perform the 3-step bootstrap.
1. Temporarily rename =config.org= to =config.original.org=.
2. Create a new =config.org= that when tangled results in Org being installed.
3. Swap back to the original =config.org=, and re-sync.

#+name: bootstrap-perform
#+begin_src emacs-lisp :noweb no-export
(print! (item "Temporarily relocating config.org to config.original.org"))
(rename-file "config.org" "config.original.org" t)
<<boostrap-create-transient-config>>
(print! (item "%s") (bold "Re-running sync"))
(exit! :restart) ; Re-run =doom sync= with the transient config.
#+end_src

With the approach worked out, we just need to generate a snipped that will
create a new =config.org= that when tangled:
+ Tangles our Org recipe to =packages.el=
+ Swaps back to the original =config.org=
+ Re-runs =doom sync=

#+name: boostrap-create-transient-config
#+begin_src emacs-lisp :noweb no-export
(print! (item "Creating minimal init.el"))

(let ((standard-output #'ignore))
  (with-temp-buffer
    (insert
     ";;; init.el -*- lexical-binding: t; -*-\n\n"
     (pp (quote
          <<bootstrap-init>>
          )))
    (write-region nil nil "init.el")))

(print! (item "Creating boostrap config.el"))

(let ((standard-output #'ignore))
  (with-temp-buffer
    (insert
     (org-element-interpret-data
      (list
       '(keyword (:key "title" :value "Boostrap Stage 1 Config" :post-blank 1))
       `(src-block
         (:language "emacs-lisp"
          :value ,(pp (quote (progn
                               <<boostrap-transition>>
                               )))
          :name "bootstrap-transition"
          :post-blank 1))
       `(src-block
         (:language "emacs-lisp"
          :parameters
          ,(concat ":noweb no-export "
                   ":tangle (expand-file-name (make-temp-name \"emacs-org-babel-excuses/confpkg-prepare-\") temporary-file-directory) "
                   ":mkdirp yes")
          :value ,(concat "<<" ; Split to avoid (prematurely) creating a noweb reference.
                          "bootstrap-transition()"
                          ">>\n"))))))
    (write-region nil nil "config.org")))
#+end_src

For the bootstrap we need a minimal =init.el=, just the literate module should be
sufficient.

#+name: bootstrap-init
#+begin_src emacs-lisp
(doom! :config literate)
#+end_src

This =config.org= simply provides an entry point for us to run elisp during
tangle. We just need to make use of it to install Org and re-sync the original
configuration.

#+name: boostrap-transition
#+begin_src emacs-lisp :noweb no-export
(setq standard-output t)

(print! (start "Starting second stage of the bootstrap."))
(print! (item "Creating minimal packages.el"))

(let ((standard-output #'ignore))
  (with-temp-buffer
    (insert
     ";; -*- no-byte-compile: t; -*-\n\n"
     (pp (quote
          (package! org)
          )))
    (write-region nil nil "packages.el")))

(doom-packages-install)

(print! (item "Switching back to original config.org"))
(rename-file "config.original.org" "config.org" t)

(print! (item "%s") (bold "Re-running sync"))
(exit! :restart)
#+end_src

There we go, that should do the trick, so long as we call the =bootstrap= block at
the start of the tangle process. This is done by calling =bootstrap= within the
[[Preparation][confpkg preparation]] stage.

** Personal Information

#+call: confpkg()

It is useful to set the basics early on, since they will be used by lots of packages... I think?
#+begin_src emacs-lisp
(setq user-full-name "Bob Goldham"
      user-mail-address "sold@sold.rip")
#+end_src

** Defaults

#+call: confpkg()

*** Basic Stuff
This is, again, largely inspired by [[https://tecosaur.github.io/emacs-config/config.html][tecosaur]] and adjusted to fit my own needs.

#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t                      ; Delete files to trash
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq undo-limit 80000000                         ; Raise undo-limit to 80Mb
      evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t                         ; Nobody likes to loose work, I certainly don't
      truncate-string-ellipsis "â¦"                ; Unicode ellispis are nicer than "...", and also save /precious/ space
      password-cache-expiry nil                   ; I can trust my computers ... can't I?
      ;;scroll-preserve-screen-position 'always     ; Don't have `point' jump around
      scroll-margin 2                             ; It's nice to maintain a little margin
      display-time-default-load-average nil)      ; I don't think I've ever found this useful

(display-time-mode 1)                             ; Enable time in the mode-line
(global-subword-mode 1)                           ; Iterate through CamelCase words
#+end_src

When using a device with a battery, it would be nice to display battery
information. We can check for a battery during tangle via noweb, and only call
~display-battery-mode~ when relevant. From a look at the various status functions
in =battery.el=, it seems like the ~?L~ key is consistently =N/A= when there is no
battery, so we'll test on that.

#+name: battery-status-setup
#+begin_src emacs-lisp :noweb-ref none
(require 'battery)
(if (and battery-status-function
         (not (equal (alist-get ?L (funcall battery-status-function))
                     "N/A")))
    (prin1-to-string `(display-battery-mode 1))
  "")
#+end_src

Now with noweb we' use the result.

#+begin_src emacs-lisp :noweb no-export
<<battery-status-setup()>>
#+end_src

*** In-Emacs Customizations

When changes are made in an interface, they are added to ~init.el~ by default. I'd rather
have them in their own separate file. Conveniently, there exists a setting to do just that:

#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name "custom.el" doom-private-dir))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

*** Opening new frames

Rarely do I need to edit the same thing twice at once. (Makes sense, right?)
When opening a new frame, I would like to get to choose which buffer to open.

First, we need to enter the new frame immediately after splitting.
#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src
Then prompt for a buffer
#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+end_src

*** New Buffers

New buffers spawning in ~fundamental-mode~ is an objectively bad decision for 99% of use-cases.
I would much prefer using ~org-mode~ by default and inferring other modes by file extension.

#+begin_src emacs-lisp
(setq-default major-mode 'org-mode)
#+end_src

** Doom Configuration

#+call: confpkg("Doom")

*** Modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:

Doom is a wonderful framework that makes modular Emacs configs easy. To accomplish this, it uses /modules/.
Each module provides a list of packages to install and configurations to apply. Various flags can be used
to adjust these on a per-module-basis.

#+name: init.el
#+attr_html: :collapsed t
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :noweb-ref none
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :input
       <<doom-input>>

       :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src

**** General Structure

As is basically the default for complex Emacs configs, this is a [[https://en.wikipedia.org/wiki/Literate_programming][literate]] configuration.
Doom supports this by default, which we can utilize through the ~literate~ module.

We also want to use (most of) Doom's default settings, including smartparens and bindings.
#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src

**** Interface

Doom offers alot of "enhancements" to the Emacs interface.
I don't use most of them, and as such do not want to spend my time loading these.

#+name: doom-completion
#+begin_src emacs-lisp
(company +tng)      ; the ultimate code completion backend
;;helm              ; the *other* search engine for love and life
;;ido               ; the other *other* search engine...
;;ivy               ; a search engine for love and life
(vertico +icons)    ; the search engine of the future
#+end_src


#+name: doom-ui
#+begin_src emacs-lisp
;;deft            ; notational velocity for Emacs
doom              ; what makes DOOM look the way it does
doom-dashboard    ; a nifty splash screen for Emacs
doom-quit         ; DOOM quit-message prompts when you quit Emacs
;;(emoji +unicode)  ; ð
hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
;;hydra
;;indent-guides     ; highlighted indent columns
;;ligatures         ; ligatures and symbols to make your code pretty again
;;minimap           ; show a map of the code on the side
modeline          ; snazzy, Atom-inspired modeline, plus API
;;nav-flash         ; blink cursor line after big motions
;;neotree           ; a project drawer, like NERDTree for vim
ophints           ; highlight the region an operation acts on
(popup +defaults)   ; tame sudden yet inevitable temporary windows
;;tabs              ; a tab bar for Emacs
;;treemacs          ; a project drawer, like neotree but cooler
;;unicode           ; extended unicode support for various languages
(vc-gutter +pretty) ; vcs diff in the fringe
vi-tilde-fringe   ; fringe tildes to mark beyond EOB
;;window-select     ; visually switch windows
workspaces        ; tab emulation, persistence & separate workspaces
;;zen               ; distraction-free coding or writing
#+end_src

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere); come to the dark side, we have cookies
file-templates    ; auto-snippets for empty files
fold              ; (nigh) universal code folding
(format +onsave)  ; automated prettiness
;;god               ; run Emacs commands without modifier keys
;;lispy             ; vim for lisp, for people who don't like vim
multiple-cursors  ; editing in many places at once
;;objed             ; text object editing for the innocent
;;parinfer          ; turn lisp into python, sort of
;;rotate-text       ; cycle region at point between text candidates
snippets          ; my elves. They type so I don't have to
;;word-wrap         ; soft wrapping with language-aware indent
#+end_src

#+name: doom-emacs
#+begin_src emacs-lisp
dired             ; making dired pretty [functional]
electric          ; smarter, keyword-based electric-indent
;;ibuffer         ; interactive buffer management
undo              ; persistent, smarter undo for your inevitable mistakes
vc                ; version-control and Emacs, sitting in a tree
#+end_src

#+name: doom-term
#+begin_src emacs-lisp
;;eshell            ; the elisp shell that works everywhere
;;shell             ; simple shell REPL for Emacs
;;term              ; basic terminal emulator for Emacs
;;vterm             ; the best terminal emulation in Emacs
#+end_src

#+name: doom-checkers
#+begin_src emacs-lisp
syntax              ; tasing you for every semicolon you forget
;;(spell +flyspell) ; tasing you for misspelling mispelling
;;grammar           ; tasing grammar mistake every you make
#+end_src

#+name: doom-tools
#+begin_src emacs-lisp
;;ansible
;;biblio            ; Writes a PhD for you (citation needed)
;;collab            ; buffers with friends
;;debugger          ; FIXME stepping through code, to help you add bugs
;;direnv
;;docker
;;editorconfig      ; let someone else argue about tabs vs spaces
;;ein               ; tame Jupyter notebooks with emacs
(eval +overlay)     ; run code, run (also, repls)
;;gist              ; interacting with github gists
lookup              ; navigate your code and its documentation
lsp               ; M-x vscode
magit             ; a git porcelain for Emacs
make              ; run make tasks from Emacs
;;pass              ; password manager for nerds
pdf               ; pdf enhancements
;;prodigy           ; FIXME managing external services & code builders
;;rgb               ; creating color strings
;;taskrunner        ; taskrunner for all your projects
;;terraform         ; infrastructure as code
;;tmux              ; an API for interacting with tmux
;;tree-sitter       ; syntax and parsing, sitting in a tree...
;;upload            ; map local to remote projects via ssh/ftp
#+end_src

#+name: doom-os
#+begin_src emacs-lisp
;;(:if IS-MAC macos)  ; improve compatibility with macOS
;;tty               ; improve the terminal Emacs experience
#+end_src

**** Language support

It should be noted that language-associated packages are /usually/ only loaded
when opening a file associated with the language or when manually entering the language's major-mode.

#+name: doom-lang
#+begin_src emacs-lisp
;;agda              ; types of types of types of types...
;;beancount         ; mind the GAAP
(cc +lsp)         ; C > C++ == 1
;;clojure           ; java with a lisp
;;common-lisp       ; if you've seen one lisp, you've seen them all
;;coq               ; proofs-as-programs
;;crystal           ; ruby at the speed of c
;;csharp            ; unity, .NET, and mono shenanigans
data              ; config/data formats
;;(dart +flutter)   ; paint ui and not much else
;;dhall
;;elixir            ; erlang done right
;;elm               ; care for a cup of TEA?
emacs-lisp        ; drown in parentheses
;;erlang            ; an elegant language for a more civilized age
ess               ; emacs speaks statistics
;;factor
;;faust             ; dsp, but you get to keep your soul
;;fortran           ; in FORTRAN, GOD is REAL (unless declared INTEGER)
;;fsharp            ; ML stands for Microsoft's Language
;;fstar             ; (dependent) types and (monadic) effects and Z3
;;gdscript          ; the language you waited for
;;(go +lsp)         ; the hipster dialect
;;(graphql +lsp)    ; Give queries a REST
;;(haskell +lsp)    ; a language that's lazier than I am
;;hy                ; readability of scheme w/ speed of python
;;idris             ; a language you can depend on
(json +lsp)       ; At least it ain't XML
;;(java +lsp)       ; the poster child for carpal tunnel syndrome
;;javascript        ; all(hope(abandon(ye(who(enter(here))))))
;;julia             ; a better, faster MATLAB
;;kotlin            ; a better, slicker Java(Script)
(latex              ; writing papers in Emacs has never been so fun
 +latexmk           ; what else would you use?
 +cdlatex           ; quick maths symbols
 +fold)             ; fold the clutter away nicities
;;lean              ; for folks with too much to prove
;;ledger            ; be audit you can be
;;lua               ; one-based indices? one-based indices
(markdown +grip)    ; writing docs for people to ignore
;;nim               ; python + lisp at the speed of c
;;nix               ; I hereby declare "nix geht mehr!"
;;ocaml             ; an objective camel
(org              ; organize your plain life in plain text
 ;;+dragndrop       ; drag & drop files/images into org buffers
 ;;+hugo            ; use Emacs for hugo blogging
 +noter           ; enhanced PDF notetaking
 ;;+jupyter         ; ipython/jupyter support for babel
 +pandoc          ; export-with-pandoc support
 ;;+gnuplot         ; who doesn't like pretty pictures
 ;;+pomodoro        ; be fruitful with the tomato technique
 +present         ; using org-mode for presentations
;;+roam2            ; wander around notes
 )
;;php               ; perl's insecure younger brother
;;plantuml          ; diagrams for confusing people more
;;purescript        ; javascript, but functional
(python +lsp +pyright)            ; beautiful is better than ugly
;;qt                ; the 'cutest' gui framework ever
;;racket            ; a DSL for DSLs
;;raku              ; the artist formerly known as perl6
;;rest              ; Emacs as a REST client
;;rst               ; ReST in peace
;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
;;(rust +lsp)       ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala             ; java, but good
;;(scheme +guile)   ; a fully conniving family of lisps
(sh +fish +lsp)                ; she sells {ba,z,fi}sh shells on the C xor
;;sml
;;solidity          ; do you need a blockchain? No.
;;swift             ; who asked for emoji variables?
;;terra             ; Earth and Moon in alignment for performance.
web               ; the tubes
;;yaml              ; JSON, but readable
;;zig               ; C, but simpler
#+end_src

**** Input

I am not from East Asia, nor do I use odd keyboard layouts.
... Why is there a mode for typing regular latin characters, but right-to-left?

#+name: doom-input
#+begin_src emacs-lisp
;;bidi                       ; (tfel ot) thgir etirw uoy gnipleh
;;chinese
;;japanese
;;layout                     ; auie,ctsrnm is the superior home row
#+end_src

**** Just a text editor, please

You can do basically anything in Emacs.
Hell, you can run Emacs in Emacs and play Doom in Doom... I want none of that.
I use Emacs for editing text, notes and source-code, and little else.


#+name: doom-email
#+begin_src emacs-lisp
;;(mu4e +org +gmail)
;;notmuch
;;(wanderlust +gmail)
#+end_src

#+name: doom-app
#+begin_src emacs-lisp
;;calendar
;;emms
;;everywhere        ; *leave* Emacs!? You must be joking
;;irc               ; how neckbeards socialize
;;(rss +org)        ; emacs as an RSS reader
;;twitter           ; twitter client https://twitter.com/vnought
#+end_src


*** Visual Settings
**** Font Face
***** Setting fonts

#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Fantasque Sans Mono" :size 24)
      doom-big-font (font-spec :family "Fantasque Sans Mono" :size 36)
      doom-emoji-font (font-spec :family "Noto Color Emoji"))
;;    doom-variable-pitch-font (font-spec :family "Overpass" :size 26)
;;    doom-unicode-font (font-spec :family "JuliaMono")
;;    doom-serif-font (font-spec :family "IBM Plex Mono" :size 22 :weight 'light))
#+end_src

***** Emojis
Except =doom-emoji-font= is not a "real" Doom variable.
So we'll just have to explicity enable it for emojis.

#+begin_src emacs-lisp
(add-hook! 'after-setting-font-hook
  (defun +emoji-set-font ()
    (set-fontset-font t 'emoji doom-emoji-font nil 'prepend)))
#+end_src

We might as well also construct a regexp to make identifying emojis if buffers
more convenient.

#+begin_src emacs-lisp
(defvar +emoji-rx
  (let (emojis)
    (map-char-table
     (lambda (char set)
       (when (eq set 'emoji)
         (push (copy-tree char) emojis)))
     char-script-table)
    (rx-to-string `(any ,@emojis)))
  "A regexp to find all emoji-script characters.")
#+end_src

For the sake of convenient insertion, we'll also register some emoji aliases
based on common usage.

#+begin_src emacs-lisp
(setq emoji-alternate-names
      '(("ð" ":)")
        ("ð" ":D")
        ("ð" ";)")
        ("ð" ":(")
        ("ð" "laughing face" "xD")
        ("ð¤£" "ROFL face")
        ("ð¢" ":'(")
        ("ð¥²" ":')")
        ("ð®" ":o")
        ("ð" ":|")
        ("ð" "cool face")
        ("ð¤ª" "goofy face")
        ("ð¤¥" "pinnochio face" "liar face")
        ("ð " ">:(")
        ("ð¡" "angry+ face")
        ("ð¤¬" "swearing face")
        ("ð¤¢" "sick face")
        ("ð" "smiling imp")
        ("ð¿" "frowning imp")
        ("â¤ï¸" "<3")
        ("ð«¡" "o7")
        ("ð" "+1")
        ("ð" "-1")
        ("ð" "left")
        ("ð" "right")
        ("ð" "up")
        ("ð¯" "100")
        ("ð¸" "flying money")))
#+end_src

Lastly, when using Emacs 28+ it would be nice to open the nice emoji dispatch
with the leader key as well as =C-x 8 e=. Since =SPC e= is unclaimed, let's just use
that until we have a better use for it (we could also split up the insertion and
                                           querying commands in other parts of the map).

#+begin_src emacs-lisp
(when (>= emacs-major-version 29)
  (map! :leader
        (:prefix ("e" . "Emoji")
         :desc "Search" "s" #'emoji-search
         :desc "Recent" "r" #'emoji-recent
         :desc "List" "l" #'emoji-list
         :desc "Describe" "d" #'emoji-describe
         :desc "Insert" "i" #'emoji-insert
         :desc "Insert" "e" #'emoji-insert)))
#+end_src

***** Checking the system

Usually, the sane approach would be to heck if all relevant fonts
are actually installed. *However*, Emacs in its current version just crashes
on startup if any of them aren't. I'll add this if it ever becomes relevant.

**** Theme

The default is ~doom-one~, so I will use ~doom-one~.
If the default changes, that's not my fault. I like this theme.

#+begin_src emacs-lisp
(setq doom-theme 'doom-one)
#+end_src

With Doom installed, there is literally no good reason to want default themes.

#+begin_src emacs-lisp
(delq! t custom-theme-load-path)
#+end_src

I have no idea what this does or how it works, I barely understand what a [[https://en.wikipedia.org/wiki/Race_condition][race condition]] is,
but apparently it helps with those...

#+begin_src emacs-lisp
(remove-hook 'window-setup-hook #'doom-init-theme-h)
(add-hook 'after-init-hook #'doom-init-theme-h 'append)
#+end_src

**** Line numbers
I love relative line numbers.
If you don't like them, you can set this to ~t~ instead.

#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src

*** Helper macros

The following helper macros are added by Doom and should be used whenever possible:
- ~load!~ for loading external ~.el~ files relative to this one
- ~use-package!~ for configuring packages
- ~add-load-path!~ for adding directories to the ~load-path~ where ~Emacs~ looks when
you load packages with ~require~ or ~use-package~
- ~map!~ for binding new keys

*** Allow babel execution in CLI actions

In this config I sometimes generate code to include in my config.
This works nicely, but for it to work with =doom sync= et. al. I need to make sure
that Org doesn't try to confirm that I want to allow evaluation (I do!).

Thankfully Doom supports =$DOOMDIR/cli.el= file which is sourced every time a CLI
command is run, so we can just enable evaluation by setting
~org-confirm-babel-evaluate~ to ~nil~ there.
While we're at it, we should silence ~org-babel-execute-src-block~ to
avoid polluting the output.

#+begin_src emacs-lisp :tangle cli.el :noweb-ref none
;;; cli.el -*- lexical-binding: t; -*-
(setq org-confirm-babel-evaluate nil)

(defun doom-shut-up-a (orig-fn &rest args)
  (quiet! (apply orig-fn args)))

(advice-add 'org-babel-execute-src-block :around #'doom-shut-up-a)
#+end_src

*** Htmlize command

Another thing ripped right from tecosaur.

#+begin_src emacs-lisp :tangle cli.el :noweb-ref none
(defcli! htmlize (file)
         "Export a FILE buffer to HTML."

         (print! "Htmlizing %s" file)

         (doom-initialize)
         (require 'highlight-numbers)
         (require 'highlight-quoted)
         (require 'rainbow-delimiters)
         (require 'engrave-faces-html)

         ;; Lighten org-mode
         (when (string= "org" (file-name-extension file))
           (setcdr (assoc 'org after-load-alist) nil)
           (setq org-load-hook nil)
           (require 'org)
           (setq org-mode-hook nil)
           (add-hook 'engrave-faces-before-hook
                     (lambda () (if (eq major-mode 'org-mode)
                                    (org-show-all)))))

         (engrave-faces-html-file file))
#+end_src

*** Org buffer creation

Let's make creating an Org buffer just that little bit easier.

#+begin_src emacs-lisp
(evil-define-command +evil-buffer-org-new (count file)
  "Creates a new ORG buffer replacing the current window, optionally
   editing a certain FILE"
  :repeat nil
  (interactive "P<f>")
  (if file
      (evil-edit file)
    (let ((buffer (generate-new-buffer "*new org*")))
      (set-window-buffer nil buffer)
      (with-current-buffer buffer
        (org-mode)
        (setq-local doom-real-buffer-p t)))))

(map! :leader
      (:prefix "b"
       :desc "New empty Org buffer" "o" #'+evil-buffer-org-new))
#+end_src

** Other Things
*** Mouse Buttons

#+call: confpkg("Better jumper mouse")

#+begin_src emacs-lisp
(map! :n [mouse-8] #'better-jumper-jump-backward
      :n [mouse-9] #'better-jumper-jump-forward)
#+end_src

*** Window Title

#+call: confpkg("Frame title")

The X/Wayland window title should just be the name of the currently active buffer and -
if applicable - project.

#+begin_src emacs-lisp
(setq frame-title-format
      '(""
        (:eval
         (if (string-match-p (regexp-quote (or (bound-and-true-p org-roam-directory) "\u0000"))
                             (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "â° "
              (subst-char-in-string ?_ ?\s buffer-file-name))
           "%b"))
        (:eval
         (when-let ((project-name (and (featurep 'projectile) (projectile-project-name))))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p) " ï %s" " ï %s") project-name))))
        ""))
#+end_src

For example when I open my config file it the window will be titled =config.org ï
doom= then as soon as I make a change it will become =config.org ï doom=.

*** Grabbing source block content as a string

In a few places in this configuration, it is desirable to grab a source block's
content as a string. We can use a noweb =<<replacement>>= form, however that
doesn't work with string escaping.

We can get around this by using noweb execution and write an name (unexported)
babel block that will grab the content of another named source block as a
string. Note that this does not currently expand nested noweb references.

#+name: grab
#+begin_src emacs-lisp :var name="" :noweb-ref none
(if-let ((block-pos (org-babel-find-named-block name))
         (block (org-element-at-point block-pos)))
    (format "%S" (string-trim (org-element-property :value block)))
  ;; look for :noweb-ref matches
  (let (block-contents)
    (org-element-cache-map
     (lambda (src)
       (when (and (not (org-in-commented-heading-p nil src))
                  (not (org-in-archived-heading-p nil src))
                  (let* ((lang (org-element-property :language src))
                         (params
                          (apply
                           #'org-babel-merge-params
                           (append
                            (org-with-point-at (org-element-property :begin src)
                              (org-babel-params-from-properties lang t))
                            (mapcar
                             (lambda (h)
                               (org-babel-parse-header-arguments h t))
                             (cons (org-element-property :parameters src)
                                   (org-element-property :header src))))))
                         (ref (alist-get :noweb-ref params)))
                    (equal ref name)))
         (push (org-babel--normalize-body src)
               block-contents)))
     :granularity 'element
     :restrict-elements '(src-block))
    (and block-contents
         (format "%S"
                 (mapconcat
                  #'identity
                  (nreverse block-contents)
                  "\n\n")))))
#+end_src

There we go, that's all it takes! This can be used via the form =<<grab("block-name")>>=.

* Packages

The heart of any Emacs config and the reason why we did all the other bits leading up to this.
Packages are what takes a barely comprehensible LISP-Interpreter like Emacs and makes it a
multifunctional, highly versatile editor/IDE.

** Loading Packages
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:

The way we load said packages is via the ~package!~ macro in =packages.el=.
This file should *never* be byte-compiled, since it would no longer be properly reinterpreted upon ~doom sync~.
#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+end_src

** Convenience
*** Which-key

#+call: confpkg("!Pkg which-key")

This helpful popup explaining keybinds is nice.
I want to see it immediately.
#+begin_src emacs-lisp
(setq which-key-idle-delay 0.25)
#+end_src

+I also think+ /tecosaur thought/ that having =evil-= appear in so many popups is a bit too verbose,
let's change that, and do a few other similar tweaks while we're at it.
#+begin_src emacs-lisp
(setq which-key-allow-multiple-replacements t)
(after! which-key
  (pushnew!
   which-key-replacement-alist
   '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "â\\1"))
   '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "â\\1"))
   ))
#+end_src

** Tools
*** Abbrev

#+call: confpkg("Multi-mode abbrev")

Abbrevs are immensely useful out-of-the-box. Buf with [[https://emacs.stackexchange.com/questions/45462/use-a-single-abbrev-table-for-multiple-modes/45476#45476][use a single abbrev-table for multiple modes? - Emacs Stack Exchange]]
they can become the best snippet-manager in existence.

#+begin_src emacs-lisp :tangle no
(add-hook 'doom-first-buffer-hook
          (defun +abbrev-file-name ()
            (setq-default abbrev-mode t)
            (setq abbrev-file-name (expand-file-name "abbrev.el" doom-private-dir))))
#+end_src

*** EVIL

#+call: confpkg("!Pkg evil")

When I want to make a substitution, I want it to be global more often than not
--- so let's make that the default.

#+begin_src emacs-lisp
(after! evil
  (setq evil-ex-substitute-global t     ; I like my s/../.. to by global by default
        evil-move-cursor-back nil       ; Don't move the block cursor when toggling insert mode
        evil-kill-on-visual-paste nil)) ; Don't put overwritten text in the kill ring
#+end_src

I don't use ~evil-escape-mode~, so I may as well turn it off, I've heard it
contributes a typing delay. I'm not sure it's much, but it is an extra
~pre-command-hook~ that I don't benefit from, so...
It seems that there's a dedicated package for this, so instead of just disabling
the mode on startup, let's prevent installation of the package.

~evil-escape-mode~ is simply weird. I don't use it, I don't think anyone does.
It also --- apparently --- adds lag to every instance of command execution or
/typing a letter/, which is a pretty big no-no in my opinion.

Out it goes:
#+begin_src emacs-lisp :tangle packages.el :noweb-ref none
(package! evil-escape :disable t)
#+end_src

*** Magit

#+call: confpkg("!Pkg Magit")

Magit is a wonderful tool, but we can do better than the default config.

#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
<<magit-toplevel>>
(after! magit
  <<magit-tweaks>>)
#+end_src

**** Easier Default Remotes
:PROPERTIES:
:header-args:emacs-lisp: :noweb-ref magit-tweaks
:END:

When creating a new project, I often want the remote to be to my personal github
account. Let's make that a bit more streamlined by introducing a quick-entry
"default forge" option.

#+begin_src emacs-lisp
(defvar +magit-default-forge-remote "git@github.com:BobGoldham/%s.git"
  "Format string that fills out to a remote from the repo name.
Set to nil to disable this functionality.")
#+end_src

While we're at it, when creating a remote with the same name as my github
username in a project where an https github remote already exists, let's make
the pre-filled remote url use ssh.

#+begin_src emacs-lisp
(defadvice! +magit-remote-add--streamline-forge-a (args)
  :filter-args #'magit-remote-add
  (interactive
   (or (and +magit-default-forge-remote
            (not (magit-list-remotes))
            (eq (read-char-choice
                 (format "Setup %s remote? [y/n]: "
                         (replace-regexp-in-string
                          "\\`\\(?:[^@]+@\\|https://\\)\\([^:/]+\\)[:/].*\\'" "\\1"
                          +magit-default-forge-remote))
                 '(?y ?n))
                ?y)
            (let* ((default-name
                     (subst-char-in-string ?\s ?-
                                           (file-name-nondirectory
                                            (directory-file-name (doom-project-root)))))
                   (name (read-string "Name: " default-name)))
              (list "origin" (format +magit-default-forge-remote name)
                    (transient-args 'magit-remote))))
       (let ((origin (magit-get "remote.origin.url"))
             (remote (magit-read-string-ns "Remote name"))
             (gh-user (magit-get "github.user")))
         (when (and (equal remote gh-user)
                    (string-match "\\`https://github\\.com/\\([^/]+\\)/\\([^/]+\\)\\.git\\'"
                                  origin)
                    (not (string= (match-string 1 origin) gh-user)))
           (setq origin (replace-regexp-in-string
                         "\\`https://github\\.com/" "git@github.com:"
                         origin)))
         (list remote
               (magit-read-url
                "Remote url"
                (and origin
                     (string-match "\\([^:/]+\\)/[^/]+\\(\\.git\\)?\\'" origin)
                     (replace-match remote t t origin 1)))
               (transient-args 'magit-remote)))))
  args)
#+end_src

**** Magit Delta

[[https://github.com/dandavison/delta/][Delta]] is a git diff syntax highlighter written in rust. The author also wrote a
package to hook this into the magit diff view (which don't get any syntax
highlighting by default). This requires the ~delta~ binary. It's packaged on some
distributions, but most reliably installed through Rust's package manager cargo.

Now we can make use of the package for this.
#+begin_src emacs-lisp :tangle packages.el :noweb-ref none
(package! magit-delta :recipe (:host github :repo "dandavison/magit-delta"))
#+end_src

All that's left is to hook it into magit
#+begin_src emacs-lisp :noweb-ref none
(magit-delta-mode +1)
#+end_src

*** Company

#+call: confpkg("!Pkg Company")

It's nice to have completions almost all the time, in my opinion. Key strokes
are just waiting to be saved!

#+begin_src emacs-lisp
(after! company
  (setq company-idle-delay 0.5
        company-minimum-prefix-length 2)
  (setq company-show-numbers t)
  (add-hook 'evil-normal-state-entry-hook #'company-abort)) ;; make aborting less annoying.
#+end_src

Now, the improvements from ~precedent~ are mostly from remembering history, so
let's improve that memory.

#+begin_src emacs-lisp
(setq-default history-length 1000)
(setq-default prescient-history-length 1000)
#+end_src

*** TRAMP

#+call: confpkg("TRAMP")

Another lovely Emacs feature, TRAMP stands for /Transparent Remote Access,
Multiple Protocol/. In brief, it's a lovely way to wander around outside your
local filesystem.

**** Prompt recognition

Unfortunately, when connecting to remote machines Tramp can be a wee pit picky
with the prompt format. Let's try to get Bash, and be a bit more permissive with
prompt recognition.

#+begin_src emacs-lisp
(after! tramp
  (setenv "SHELL" "/bin/bash")
  (setq tramp-shell-prompt-pattern "\\(?:^\\|\n\\|\x0d\\)[^]#$%>\n]*#?[]#$%>î°] *\\(\e\\[[0-9;]*[a-zA-Z] *\\)*")) ;; default + î°
#+end_src

*** Auto activating snippets

#+call: confpkg("!Pkg AAS")

Sometimes pressing =TAB= is just too much.
#+begin_src emacs-lisp :tangle packages.el
(package! aas :recipe (:host github :repo "ymarco/auto-activating-snippets"))
#+end_src

#+begin_src emacs-lisp
(use-package! aas
  :commands aas-mode)
#+end_src

*** YASnippet

#+call: confpkg("!Pkg YASnippet")

#+begin_quote
From the =:editor snippets= module.
#+end_quote

Nested snippets are good, so let's enable that.
#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src

*** Smart Parentheses

#+call: confpkg("!Pkg SmartParens")

#+begin_src emacs-lisp
(sp-local-pair
 '(org-mode)
 "<<" ">>"
 :actions '(insert))
#+end_src

** Visuals

Why is this not in the other Visuals block?
Because this is installing new packages and thus needs to be tangled appropriately.

*** Info Colours

#+call: confpkg("!Pkg Info colors")

This makes manual pages nicer to look at by adding variable pitch fontification
and colouring ð.

#+begin_src emacs-lisp :tangle packages.el
(package! info-colors)
#+end_src

To use this we'll just hook it into =Info=.

#+begin_src emacs-lisp
(use-package! info-colors
  :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)
#+end_src

*** Modus Themes

These are in Emacs28 by default, but updates come in frequently and I'd like to keep up.

#+begin_src emacs-lisp :tangle packages.el
(package! modus-themes)
#+end_src

*** Spacemacs Themes

Because why not?

#+begin_src emacs-lisp :tangle packages.el
(package! spacemacs-theme)
#+end_src

*** Doom modeline

#+call: confpkg("!Pkg Doom modeline", after="doom-modeline")

**** PDF modeline

I think the PDF modeline could do with tweaking. I raised [[https://github.com/seagle0128/doom-modeline/pull/425][an issue]] on this,
however the response was basically "put your preferences in your personal
config, the current default is sensible" --- so here we are.

First up I'm going to want a segment for just the buffer file name, and a PDF
icon. Then we'll redefine two functions used to generate the modeline.

#+begin_src emacs-lisp
(doom-modeline-def-segment buffer-name
  "Display the current buffer's name, without any other information."
  (concat
   doom-modeline-spc
   (doom-modeline--buffer-name)))

(doom-modeline-def-segment pdf-icon
  "PDF icon from nerd-icons."
  (concat
   doom-modeline-spc
   (doom-modeline-icon sucicon "nf-seti-pdf" nil nil
                       :face (if (doom-modeline--active)
                                 'nerd-icons-red
                               'mode-line-inactive)
                       :v-adjust 0.02)))

(defun doom-modeline-update-pdf-pages ()
  "Update PDF pages."
  (setq doom-modeline--pdf-pages
        (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
              (total-page-str (number-to-string (pdf-cache-number-of-pages))))
          (concat
           (propertize
            (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                    " P" current-page-str)
            'face 'mode-line)
           (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

(doom-modeline-def-segment pdf-pages
  "Display PDF pages."
  (if (doom-modeline--active) doom-modeline--pdf-pages
    (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

(doom-modeline-def-modeline 'pdf
  '(bar window-number pdf-pages pdf-icon buffer-name)
  '(misc-info matches major-mode process vcs))
#+end_src

*** Marginalia

#+call: confpkg("!Pkg Marginalia")

Vertico Marginalia is quite nice, but the metadata annotations could be better than the default.

#+begin_src emacs-lisp
(after! marginalia
  (setq marginalia-censor-variables nil)

  (defadvice! +marginalia--anotate-local-file-colorful (cand)
    "Just a more colourful version of `marginalia--anotate-local-file'."
    :override #'marginalia--annotate-local-file
    (when-let (attrs (file-attributes (substitute-in-file-name
                                       (marginalia--full-candidate cand))
                                      'integer))
      (marginalia--fields
       ((marginalia--file-owner attrs)
        :width 12 :face 'marginalia-file-owner)
       ((marginalia--file-modes attrs))
       ((+marginalia-file-size-colorful (file-attribute-size attrs))
        :width 7)
       ((+marginalia--time-colorful (file-attribute-modification-time attrs))
        :width 12))))

  (defun +marginalia--time-colorful (time)
    (let* ((seconds (float-time (time-subtract (current-time) time)))
           (color (doom-blend
                   (face-attribute 'marginalia-date :foreground nil t)
                   (face-attribute 'marginalia-documentation :foreground nil t)
                   (/ 1.0 (log (+ 3 (/ (+ 1 seconds) 345600.0)))))))
      ;; 1 - log(3 + 1/(days + 1)) % grey
      (propertize (marginalia--time time) 'face (list :foreground color))))

  (defun +marginalia-file-size-colorful (size)
    (let* ((size-index (/ (log10 (+ 1 size)) 7.0))
           (color (if (< size-index 10000000) ; 10m
                      (doom-blend 'orange 'green size-index)
                    (doom-blend 'red 'orange (- size-index 1)))))
      (propertize (file-size-human-readable size) 'face (list :foreground color)))))
#+end_src

*** Centaur Tabs

#+call: confpkg("!Pkg Centaur Tabs")

#+begin_quote
From the =:ui tabs= module.
#+end_quote

We want to make the tabs a nice, comfy size (~36~), with icons. The modifier
marker is nice, but the particular default Unicode one causes a lag spike, so
let's just switch to an ~o~, which still looks decent but doesn't cause any
issues.
An 'active-bar' is nice, so let's have one of those. If we have it ~under~ needs us to
turn on ~x-underline-at-decent~ though. For some reason this didn't seem to work
inside the src_elisp{(after! ... )} block Â¯\_(ã)_/Â¯.
Then let's change the font to a sans serif, but the default one doesn't fit too
well somehow, so let's switch to 'P22 Underground Book'; it looks much nicer.

#+begin_src emacs-lisp
(after! centaur-tabs
  (centaur-tabs-mode -1)
  (setq centaur-tabs-height 36
        centaur-tabs-set-icons t
        centaur-tabs-modified-marker "o"
        centaur-tabs-close-button "Ã"
        centaur-tabs-set-bar 'above
        centaur-tabs-gray-out-icons 'buffer)
  (centaur-tabs-change-fonts "P22 Underground Book" 160))
;; (setq x-underline-at-descent-line t)
#+end_src

*** Nerd Icons

#+call: confpkg("!Pkg Nerd Icons")

This is better than ~all-the-icons~, according to some guy on reddit.

#+begin_src emacs-lisp
(after! nerd-icons
  (setcdr (assoc "m" nerd-icons-extension-icon-alist)
          (cdr (assoc "matlab" nerd-icons-extension-icon-alist))))
#+end_src

** Basic Necessities (Frivolities)

*** Elcord

#+call: confpkg("!Pkg Elcord")

What's even the point of using Emacs unless you're constantly telling everyone
about it?
#+begin_src emacs-lisp :tangle packages.el
(package! elcord)
#+end_src

#+begin_src emacs-lisp
(use-package! elcord
  :commands elcord-mode
  :config
  (setq elcord-use-major-mode-as-main-icon t))

(elcord-mode)
#+end_src

** File Types
*** Systemd

#+call: confpkg("!Pkg Systemd")

Wonderful for editing unitfiles, as one does...
#+begin_src emacs-lisp :tangle packages.el
(package! systemd)
#+end_src

#+begin_src emacs-lisp
(use-package! systemd
  :defer t)
#+end_src

* Language Configuration

** File type defaults

#+call: confpkg()

For some file types, we overwrite defaults in the [[file:./snippets][snippets]] directory, others
need to have a template assigned.

#+begin_src emacs-lisp
(set-file-template! "\\.tex$" :trigger "__" :mode 'latex-mode)
(set-file-template! "\\.org$" :trigger "__" :mode 'org-mode)
(set-file-template! "/LICEN[CS]E$" :trigger '+file-templates/insert-license)
#+end_src

** Plaintext

#+call: confpkg()

It's nice to see ANSI colour codes displayed, however we don't want to disrupt
ANSI codes in Org src blocks.

#+begin_src emacs-lisp
(after! text-mode
  (add-hook! 'text-mode-hook
    (unless (derived-mode-p 'org-mode)
      ;; Apply ANSI color codes
      (with-silent-modifications
        (ansi-color-apply-on-region (point-min) (point-max) t)))))
#+end_src

** Org
:PROPERTIES:
:CUSTOM_ID: org
:END:

:intro:
Arguably Emacs' greatest feature.
:end:

There's so much to be said about this, I don't even know how or where to begin.

*** System Setup
**** MIME-Type

Org is not usually recognized as its own ~MIMEtype~ by default.
But we can easily fix that like so:

#+begin_src xml :tangle ~/.local/share/mime/packages/org.xml :mkdirp yes :comments no
<mime-info xmlns='http://www.freedesktop.org/standards/shared-mime-info'>
  <mime-type type="text/org">
    <comment>Emacs Org-mode File</comment>
    <glob pattern="*.org"/>
    <alias type="text/org"/>
  </mime-type>
</mime-info>
#+end_src

What's nice is that Papirus [[https://github.com/PapirusDevelopmentTeam/papirus-icon-theme/commit/a10fb7f2423d5e30b9c4477416ccdc93c4f3849d][now]] has an icon for =text/org=.
One simply needs to refresh their mime database
#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "") "setup.sh" "no")
update-mime-database ~/.local/share/mime
#+end_src
Then set Emacs as the default editor
#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "emacs-client.desktop\n") "no" "setup.sh")
xdg-mime default emacs.desktop text/org
#+end_src


**** Git Diff

Protesilaos wrote a [[https://protesilaos.com/codelog/2021-01-26-git-diff-hunk-elisp-org/][very helpful article]] in which he explains how to change the
git diff chunk heading to something more useful than just the immediate line
above the hunk --- like the parent heading.

This can be achieved by first adding a new diff mode to git in =~/.config/git/attributes=
#+begin_src fundamental
,*.org   diff=org
#+end_src

Then adding a regex for it to =~/.config/git/config=
#+begin_src gitconfig
[diff "org"]
  xfuncname = "^(\\*+ +.*)$"
#+end_src

*** Packages
**** Visuals
***** Org Modern

#+call: confpkg("!Pkg org-modern")

Making =org-mode= beautiful is important. =org-modern= is a good place to start.

#+begin_src emacs-lisp :tangle packages.el
(package! org-modern)
#+end_src

... Of course the defaults are not as great as they could be.

#+begin_src emacs-lisp
(use-package! org-modern
  :hook (org-mode . org-modern-mode)
  :config
  (setq org-modern-star '("â" "â" "â¸" "â¿" "â¤" "â" "â" "â¶")
        org-modern-table-vertical 1
        org-modern-table-horizontal 0.2
        org-modern-list '((43 . "â¤")
                          (45 . "â")
                          (42 . "â¢"))
        org-modern-todo-faces
        '(("TODO" :inverse-video t :inherit org-todo)
          ("PROJ" :inverse-video t :inherit +org-todo-project)
          ("STRT" :inverse-video t :inherit +org-todo-active)
          ("[-]"  :inverse-video t :inherit +org-todo-active)
          ("HOLD" :inverse-video t :inherit +org-todo-onhold)
          ("WAIT" :inverse-video t :inherit +org-todo-onhold)
          ("[?]"  :inverse-video t :inherit +org-todo-onhold)
          ("KILL" :inverse-video t :inherit +org-todo-cancel)
          ("NO"   :inverse-video t :inherit +org-todo-cancel))
        org-modern-footnote
        (cons nil (cadr org-script-display))
        org-modern-block-fringe nil
        org-modern-block-name
        '((t . t)
          ("src" "Â»" "Â«")
          ("example" "Â»â" "âÂ«")
          ("quote" "â" "â")
          ("export" "â©" "âª"))
        org-modern-progress nil
        org-modern-priority nil
        org-modern-horizontal-rule (make-string 36 ?â)
        org-modern-keyword
        '((t . t)
          ("title" . "ð")
          ("subtitle" . "ð©")
          ("author" . "ð¼")
          ("email" . #("î¡" 0 1 (display (raise -0.14))))
          ("date" . "ð¿")
          ("property" . "â¸")
          ("options" . "â¥")
          ("startup" . "â»")
          ("macro" . "ð")
          ("bind" . #("î" 0 1 (display (raise -0.1))))
          ("bibliography" . "ï")
          ("print_bibliography" . #("î" 0 1 (display (raise -0.1))))
          ("cite_export" . "ïâ®­")
          ("print_glossary" . #("îá´¬á¶»" 0 1 (display (raise -0.1))))
          ("glossary_sources" . #("î" 0 1 (display (raise -0.14))))
          ("include" . "â¤")
          ("setupfile" . "â")
          ("html_head" . "ð·")
          ("html" . "ð")
          ("latex_class" . "ð»")
          ("latex_class_options" . #("ð»î¢¸" 1 2 (display (raise -0.14))))
          ("latex_header" . "ð»")
          ("latex_header_extra" . "ð»âº")
          ("latex" . "ð")
          ("beamer_theme" . "ð±")
          ("beamer_color_theme" . #("ð±î" 1 2 (display (raise -0.12))))
          ("beamer_font_theme" . "ð±ð")
          ("beamer_header" . "ð±")
          ("beamer" . "ð")
          ("attr_latex" . "ð")
          ("attr_html" . "ð")
          ("attr_org" . "âª")
          ("call" . #("î¦" 0 1 (display (raise -0.15))))
          ("name" . "â")
          ("header" . "âº")
          ("caption" . "â°")
          ("results" . "ð ¶")))
  (custom-set-faces! '(org-modern-statistics :inherit org-checkbox-statistics-todo)))
#+end_src
Since =org-modern='s tag face supplants Org's tag face, we need to adjust the
spell-check face ignore list

#+begin_src emacs-lisp
(after! spell-fu
  (cl-pushnew 'org-modern-tag (alist-get 'org-mode +spell-excluded-faces-alist)))
#+end_src

***** Emphasis Markers

#+call: confpkg("!Pkg org-appear")

While ~org-hide-emphasis-markers~ is very nice, it can sometimes make edits which
occur at the border a bit more fiddley. We can improve this situation without
sacrificing visual amenities with the =org-appear= package.
#+begin_src emacs-lisp :tangle packages.el
(package! org-appear :recipe (:host github :repo "awth13/org-appear"))
#+end_src

#+begin_src emacs-lisp
(use-package! org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-inside-latex t
        org-appear-autolinks t)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src

**** Extra Functionality

***** Transclusion

#+call: confpkg("!Pkg org-transclusion")

There's a really cool package in development to /transclude/ Org document content.
#+begin_src emacs-lisp :tangle packages.el
(package! org-transclusion :recipe (:host github :repo "nobiot/org-transclusion"))
#+end_src

#+begin_src emacs-lisp
(use-package! org-transclusion
  :commands org-transclusion-mode
  :init
  (map! :after org :map org-mode-map
        "<f12>" #'org-transclusion-mode))
#+end_src

***** Document Structure as a Graph

#+call: confpkg("!Pkg org-graph-view")

Came across this and ... it's cool
#+begin_src emacs-lisp :tangle packages.el
(package! org-graph-view :recipe (:host github :repo "alphapapa/org-graph-view") :pin "233c6708c1f37fc60604de49ca192497aef39757")
#+end_src

***** Just Another Pandoc Format

#+call: confpkg("!Pkg org-pandoc-import")

Sometimes I'm given non-org files, that's very sad. Luckily Pandoc offers a way
to make that right again, and this package makes that even easier to do.
#+begin_src emacs-lisp :tangle packages.el
(package! org-pandoc-import :recipe
  (:host github :repo "tecosaur/org-pandoc-import" :files ("*.el" "filters" "preprocessors")))
#+end_src

#+begin_src emacs-lisp
(use-package! org-pandoc-import
  :after org)
#+end_src

***** Comparing Documents

#+call: confpkg("!Pkg orgdiff")

It's quite nice to compare Org files, and the richest way to compare content is
probably =latexdiff=. There are a few annoying steps involved here, and so I've
written a package to streamline the process.

#+begin_src emacs-lisp :tangle packages.el
(package! orgdiff :recipe (:host github :repo "tecosaur/orgdiff"))
#+end_src

The only little annoyance is the fact that =latexdiff= uses ~#FF0000~ and ~#0000FF~ as
the red/blue change indication colours. We can make this a bit nicer by
post-processing the =latexdiff= result.

#+begin_src emacs-lisp
(use-package! orgdiff
  :defer t
  :config
  (defun +orgdiff-nicer-change-colours ()
    (goto-char (point-min))
    ;; Set red/blue based on whether chameleon is being used
    (if (search-forward "%% make document follow Emacs theme" nil t)
        (setq red  (substring (doom-blend 'red 'fg 0.8) 1)
              blue (substring (doom-blend 'blue 'teal 0.6) 1))
      (setq red  "c82829"
            blue "00618a"))
    (when (and (search-forward "%DIF PREAMBLE EXTENSION ADDED BY LATEXDIFF" nil t)
               (search-forward "\\RequirePackage{color}" nil t))
      (when (re-search-forward "definecolor{red}{rgb}{1,0,0}" (cdr (bounds-of-thing-at-point 'line)) t)
        (replace-match (format "definecolor{red}{HTML}{%s}" red)))
      (when (re-search-forward "definecolor{blue}{rgb}{0,0,1}" (cdr (bounds-of-thing-at-point 'line)) t)
        (replace-match (format "definecolor{blue}{HTML}{%s}" blue)))))
  (add-to-list 'orgdiff-latexdiff-postprocess-hooks #'+orgdiff-nicer-change-colours))
#+end_src

*** Behavior

#+call: confpkg("Org Behavior", after="org")

**** Tweaking Defaults

#+begin_src emacs-lisp
(setq org-directory "~/Documents/org/"      ; Where I want my org files
      org-agenda-files (list org-directory) ; This seems like it should be obvious
      org-use-property-inheritance t        ; It's convenient to inherit properties from supersections.
      org-log-done 'time                    ; The time an item is done
      org-list-allow-alphabetical t         ; Make a. A. a) A) list bullets
      org-catch-invisible-edits 'smart      ; Try not to mess up invisible regions
      org-export-with-sub-superscripts '{}  ; sub/superscript require _{}/^{}
      org-export-allow-bind-keywords t)     ; Bind keywords? TODO: Figure out what that means
#+end_src

We should also set up some deafult header args...

#+begin_src emacs-lisp
(setq org-babel-default-header-args
      '((:session . "none")
        (:results . "replace")
        (:exports . "code")
        (:cache . "no")
        (:noweb . "no")
        (:hlines . "no")
        (:tangle . "no")
        (:comments . "link")))
#+end_src

By default, ~visual-line-mode~ is turned =on=, and ~auto-fill-mode~ =off= by a hook.
However this messes with tables in Org-mode, and other plaintext files (e.g.
markdown, \LaTeX) so I'll turn it off for this, and manually enable it for more
specific modes as desired.
#+begin_src emacs-lisp
(remove-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'text-mode-hook #'auto-fill-mode)
#+end_src

**** Extra Functionality

***** Zero-Width Spaces

Occasionally in Org you run into annoyances where you want to have two seperate
blocks right together without a space. For example, to *empâh*âasise part of a word,
or put a currency symbol immediately before an inline source block.
There is a solution to this, it just sounds slightly hacky --- zero width spaces.
Because this is Emacs, we can make this feel much less hacky by making a minor
addition to the Org key map ð.
#+begin_src emacs-lisp
(map! :map org-mode-map
      :nie "M-SPC M-SPC" (cmd! (insert "\u200B")))
#+end_src

We then want to stop the space from being included in exports, which can be done
with a little filter.
#+begin_src emacs-lisp
(defun +org-export-remove-zero-width-space (text _backend _info)
  "Remove zero width spaces from TEXT."
  (unless (org-export-derived-backend-p 'org)
    (replace-regexp-in-string "\u200B" "" text)))

(after! ox
  (add-to-list 'org-export-filter-final-output-functions #'+org-export-remove-zero-width-space t))
#+end_src

***** List bullet sequence

I think it makes sense to have list bullets change with depth
#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+") ("*" . "+") ("1." . "a.")))
#+end_src

***** Easier file links

While ~org-insert-link~ is all very well and good, a large portion of the time I
want to insert a file, and so it would be good to have a way to skip straight to
that and avoid the description prompt. Looking at ~org-link-parameters~, we can
see that the ="file"= link type uses the completion function
~org-link-complete-file~, so let's use that to make a little file-link inserting
function.

#+begin_src emacs-lisp
(defun +org-insert-file-link ()
  "Insert a file link.  At the prompt, enter the filename."
  (interactive)
  (insert (format "[[%s]]" (org-link-complete-file))))
#+end_src

Now we'll just add that under the Org mode link localleader for convenience.

#+begin_src emacs-lisp
(map! :after org
      :map org-mode-map
      :localleader
      "l f" #'+org-insert-file-link)
#+end_src

***** cdlatex

It's also nice to be able to use ~cdlatex~.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+end_src

It's handy to be able to quickly insert environments with =C-c }=. I almost always
want to edit them afterwards though, so let's make that happen by default.
#+begin_src emacs-lisp
(defadvice! org-edit-latex-emv-after-insert ()
  :after #'org-cdlatex-environment-indent
  (org-edit-latex-environment))
#+end_src

***** LSP support in ~src~ blocks

Now, by default, LSPs don't really function at all in ~src~ blocks.
But they're really useful and I'd like to have them.
#+begin_src emacs-lisp
(cl-defmacro lsp-org-babel-enable (lang)
  "Support LANG in org source code block."
  (setq centaur-lsp 'lsp-mode)
  (cl-check-type lang stringp)
  (let* ((edit-pre (intern (format "org-babel-edit-prep:%s" lang)))
         (intern-pre (intern (format "lsp--%s" (symbol-name edit-pre)))))
    `(progn
       (defun ,intern-pre (info)
         (let ((file-name (->> info caddr (alist-get :file))))
           (unless file-name
             (setq file-name (make-temp-file "babel-lsp-")))
           (setq buffer-file-name file-name)
           (lsp-deferred)))
       (put ',intern-pre 'function-documentation
            (format "Enable lsp-mode in the buffer of org source block (%s)."
                    (upcase ,lang)))
       (if (fboundp ',edit-pre)
           (advice-add ',edit-pre :after ',intern-pre)
         (progn
           (defun ,edit-pre (info)
             (,intern-pre info))
           (put ',edit-pre 'function-documentation
                (format "Prepare local buffer environment for org source block (%s)."
                        (upcase ,lang))))))))
(defvar org-babel-lang-list
  '("go" "python" "ipython" "bash" "sh"))
(dolist (lang org-babel-lang-list)
  (eval `(lsp-org-babel-enable ,lang)))
#+end_src

***** View exported file

='localeader v= has no pre-existing binding, so I may as well use it with the same
functionality as in LaTeX. Let's try viewing possible output files with this.
#+begin_src emacs-lisp
(map! :map org-mode-map
      :localleader
      :desc "View exported file" "v" #'org-view-output-file)

(defun org-view-output-file (&optional org-file-path)
  "Visit buffer open on the first output file (if any) found, using `org-view-output-file-extensions'"
  (interactive)
  (let* ((org-file-path (or org-file-path (buffer-file-name) ""))
         (dir (file-name-directory org-file-path))
         (basename (file-name-base org-file-path))
         (output-file nil))
    (dolist (ext org-view-output-file-extensions)
      (unless output-file
        (when (file-exists-p
               (concat dir basename "." ext))
          (setq output-file (concat dir basename "." ext)))))
    (if output-file
        (if (member (file-name-extension output-file) org-view-external-file-extensions)
            (browse-url-xdg-open output-file)
          (pop-to-buffer (or (find-buffer-visiting output-file)
                             (find-file-noselect output-file))))
      (message "No exported file found"))))

(defvar org-view-output-file-extensions '("pdf" "md" "rst" "txt" "tex" "html")
  "Search for output files with these extensions, in order, viewing the first that matches")
(defvar org-view-external-file-extensions '("html")
  "File formats that should be opened externally.")
#+end_src

**** Nicer generated heading IDs

Thanks to alphapapa's [[https://github.com/alphapapa/unpackaged.el#export-to-html-with-useful-anchors][unpackaged.el]].

By default, Org generated heading IDs like =#org80fc2a5= which ... works, but has
two issues
+ It's completely uninformative, I have no idea what's being referenced
+ If I export the same file, everything will change.
  Now, while without hardcoded values it's impossible to set references in
  stone, it would be nice for there to be a decent chance of staying the same.

Both of these issues can be addressed by generating IDs like
=#language-configuration=, which is what I'll do here.

It's worth noting that alphapapa's use of ~url-hexify-string~ seemed to cause me
some issues. Replacing that in ~a53899~ resolved this for me. To go one step
further, I create a function for producing nice short links, like an inferior
version of ~reftex-label~.

#+begin_src emacs-lisp
(defvar org-reference-contraction-max-words 3
  "Maximum number of words in a reference reference.")
(defvar org-reference-contraction-max-length 35
  "Maximum length of resulting reference reference, including joining characters.")
(defvar org-reference-contraction-stripped-words
  '("the" "on" "in" "off" "a" "for" "by" "of" "and" "is" "to")
  "Superfluous words to be removed from a reference.")
(defvar org-reference-contraction-joining-char "-"
  "Character used to join words in the reference reference.")

(defun org-reference-contraction-truncate-words (words)
  "Using `org-reference-contraction-max-length' as the total character 'budget' for the WORDS
and truncate individual words to conform to this budget.

To arrive at a budget that accounts for words undershooting their requisite average length,
the number of characters in the budget freed by short words is distributed among the words
exceeding the average length.  This adjusts the per-word budget to be the maximum feasable for
this particular situation, rather than the universal maximum average.

This budget-adjusted per-word maximum length is given by the mathematical expression below:

max length = \\floor{ \\frac{total length - chars for seperators - \\sum_{word \\leq average length} length(word) }{num(words) > average length} }"
  ;; trucate each word to a max word length determined by
  ;;
  (let* ((total-length-budget (- org-reference-contraction-max-length  ; how many non-separator chars we can use
                                 (1- (length words))))
         (word-length-budget (/ total-length-budget                      ; max length of each word to keep within budget
                                org-reference-contraction-max-words))
         (num-overlong (-count (lambda (word)                            ; how many words exceed that budget
                                 (> (length word) word-length-budget))
                               words))
         (total-short-length (-sum (mapcar (lambda (word)                ; total length of words under that budget
                                             (if (<= (length word) word-length-budget)
                                                 (length word) 0))
                                           words)))
         (max-length (/ (- total-length-budget total-short-length)       ; max(max-length) that we can have to fit within the budget
                        num-overlong)))
    (mapcar (lambda (word)
              (if (<= (length word) max-length)
                  word
                (substring word 0 max-length)))
            words)))

(defun org-reference-contraction (reference-string)
  "Give a contracted form of REFERENCE-STRING that is only contains alphanumeric characters.
Strips 'joining' words present in `org-reference-contraction-stripped-words',
and then limits the result to the first `org-reference-contraction-max-words' words.
If the total length is > `org-reference-contraction-max-length' then individual words are
truncated to fit within the limit using `org-reference-contraction-truncate-words'."
  (let ((reference-words
         (-filter (lambda (word)
                    (not (member word org-reference-contraction-stripped-words)))
                  (split-string
                   (->> reference-string
                        downcase
                        (replace-regexp-in-string "\\[\\[[^]]+\\]\\[\\([^]]+\\)\\]\\]" "\\1") ; get description from org-link
                        (replace-regexp-in-string "[-/ ]+" " ") ; replace seperator-type chars with space
                        puny-encode-string
                        (replace-regexp-in-string "^xn--\\(.*?\\) ?-?\\([a-z0-9]+\\)$" "\\2 \\1") ; rearrange punycode
                        (replace-regexp-in-string "[^A-Za-z0-9 ]" "") ; strip chars which need %-encoding in a uri
                        ) " +"))))
    (when (> (length reference-words)
             org-reference-contraction-max-words)
      (setq reference-words
            (cl-subseq reference-words 0 org-reference-contraction-max-words)))

    (when (> (apply #'+ (1- (length reference-words))
                    (mapcar #'length reference-words))
             org-reference-contraction-max-length)
      (setq reference-words (org-reference-contraction-truncate-words reference-words)))

    (string-join reference-words org-reference-contraction-joining-char)))
#+end_src

Now here's alphapapa's subtly tweaked mode.
#+begin_src emacs-lisp
(define-minor-mode unpackaged/org-export-html-with-useful-ids-mode
  "Attempt to export Org as HTML with useful link IDs.
Instead of random IDs like \"#orga1b2c3\", use heading titles,
made unique when necessary."
  :global t
  (if unpackaged/org-export-html-with-useful-ids-mode
      (advice-add #'org-export-get-reference :override #'unpackaged/org-export-get-reference)
    (advice-remove #'org-export-get-reference #'unpackaged/org-export-get-reference)))
(unpackaged/org-export-html-with-useful-ids-mode 1) ; ensure enabled, and advice run

(defun unpackaged/org-export-get-reference (datum info)
  "Like `org-export-get-reference', except uses heading titles instead of random numbers."
  (let ((cache (plist-get info :internal-references)))
    (or (car (rassq datum cache))
        (let* ((crossrefs (plist-get info :crossrefs))
               (cells (org-export-search-cells datum))
               ;; Preserve any pre-existing association between
               ;; a search cell and a reference, i.e., when some
               ;; previously published document referenced a location
               ;; within current file (see
               ;; `org-publish-resolve-external-link').
               ;;
               ;; However, there is no guarantee that search cells are
               ;; unique, e.g., there might be duplicate custom ID or
               ;; two headings with the same title in the file.
               ;;
               ;; As a consequence, before re-using any reference to
               ;; an element or object, we check that it doesn't refer
               ;; to a previous element or object.
               (new (or (cl-some
                         (lambda (cell)
                           (let ((stored (cdr (assoc cell crossrefs))))
                             (when stored
                               (let ((old (org-export-format-reference stored)))
                                 (and (not (assoc old cache)) stored)))))
                         cells)
                        (when (org-element-property :raw-value datum)
                          ;; Heading with a title
                          (unpackaged/org-export-new-named-reference datum cache))
                        (when (member (car datum) '(src-block table example fixed-width property-drawer))
                          ;; Nameable elements
                          (unpackaged/org-export-new-named-reference datum cache))
                        ;; NOTE: This probably breaks some Org Export
                        ;; feature, but if it does what I need, fine.
                        (org-export-format-reference
                         (org-export-new-reference cache))))
               (reference-string new))
          ;; Cache contains both data already associated to
          ;; a reference and in-use internal references, so as to make
          ;; unique references.
          (dolist (cell cells) (push (cons cell new) cache))
          ;; Retain a direct association between reference string and
          ;; DATUM since (1) not every object or element can be given
          ;; a search cell (2) it permits quick lookup.
          (push (cons reference-string datum) cache)
          (plist-put info :internal-references cache)
          reference-string))))

(defun unpackaged/org-export-new-named-reference (datum cache)
  "Return new reference for DATUM that is unique in CACHE."
  (cl-macrolet ((inc-suffixf (place)
                             `(progn
                                (string-match (rx bos
                                                  (minimal-match (group (1+ anything)))
                                                  (optional "--" (group (1+ digit)))
                                                  eos)
                                              ,place)
                                ;; HACK: `s1' instead of a gensym.
                                (-let* (((s1 suffix) (list (match-string 1 ,place)
                                                           (match-string 2 ,place)))
                                        (suffix (if suffix
                                                    (string-to-number suffix)
                                                  0)))
                                  (setf ,place (format "%s--%s" s1 (cl-incf suffix)))))))
    (let* ((headline-p (eq (car datum) 'headline))
           (title (if headline-p
                      (org-element-property :raw-value datum)
                    (or (org-element-property :name datum)
                        (concat (org-element-property :raw-value
                                                      (org-element-property :parent
                                                                            (org-element-property :parent datum)))))))
           ;; get ascii-only form of title without needing percent-encoding
           (ref (concat (org-reference-contraction (substring-no-properties title))
                        (unless (or headline-p (org-element-property :name datum))
                          (concat ","
                                  (pcase (car datum)
                                    ('src-block "code")
                                    ('example "example")
                                    ('fixed-width "mono")
                                    ('property-drawer "properties")
                                    (_ (symbol-name (car datum))))
                                  "--1"))))
           (parent (when headline-p (org-element-property :parent datum))))
      (while (--any (equal ref (car it))
                    cache)
        ;; Title not unique: make it so.
        (if parent
            ;; Append ancestor title.
            (setf title (concat (org-element-property :raw-value parent)
                                "--" title)
                  ;; get ascii-only form of title without needing percent-encoding
                  ref (org-reference-contraction (substring-no-properties title))
                  parent (when headline-p (org-element-property :parent parent)))
          ;; No more ancestors: add and increment a number.
          (inc-suffixf ref)))
      ref)))

(add-hook 'org-load-hook #'unpackaged/org-export-html-with-useful-ids-mode)
#+end_src
We also need to redefine src_elisp{(org-export-format-reference)} as it now may
be passed a string as well as a number.
#+begin_src emacs-lisp
(defadvice! org-export-format-reference-a (reference)
  "Format REFERENCE into a string.

REFERENCE is a either a number or a string representing a reference,
as returned by `org-export-new-reference'."
  :override #'org-export-format-reference
  (if (stringp reference) reference (format "org%07x" reference)))
#+end_src

**** Nicer ~org-return~

Once again, from [[https://github.com/alphapapa/unpackaged.el#org-return-dwim][unpackaged.el]]
#+begin_src emacs-lisp
(defun unpackaged/org-element-descendant-of (type element)
  "Return non-nil if ELEMENT is a descendant of TYPE.
TYPE should be an element type, like `item' or `paragraph'.
ELEMENT should be a list like that returned by `org-element-context'."
  ;; MAYBE: Use `org-element-lineage'.
  (when-let* ((parent (org-element-property :parent element)))
    (or (eq type (car parent))
        (unpackaged/org-element-descendant-of type parent))))

;;;###autoload
(defun unpackaged/org-return-dwim (&optional default)
  "A helpful replacement for `org-return-indent'.  With prefix, call `org-return-indent'.

On headings, move point to position after entry content.  In
lists, insert a new item or end the list, with checkbox if
appropriate.  In tables, insert a new row or end the table."
  ;; Inspired by John Kitchin: http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/
  (interactive "P")
  (if default
      (org-return t)
    (cond
     ;; Act depending on context around point.

     ;; NOTE: I prefer RET to not follow links, but by uncommenting this block, links will be
     ;; followed.

     ((eq 'link (car (org-element-context)))
     ;; Link: Open it.
     (org-open-at-point-global))

     ((org-at-heading-p)
      ;; Heading: Move to position after entry content.
      ;; NOTE: This is probably the most interesting feature of this function.
      (let ((heading-start (org-entry-beginning-position)))
        (goto-char (org-entry-end-position))
        (cond ((and (org-at-heading-p)
                    (= heading-start (org-entry-beginning-position)))
               ;; Entry ends on its heading; add newline after
               (end-of-line)
               (insert "\n\n"))
              (t
               ;; Entry ends after its heading; back up
               (forward-line -1)
               (end-of-line)
               (when (org-at-heading-p)
                 ;; At the same heading
                 (forward-line)
                 (insert "\n")
                 (forward-line -1))
               (while (not (looking-back "\\(?:[[:blank:]]?\n\\)\\{3\\}" nil))
                 (insert "\n"))
               (forward-line -1)))))

     ((org-at-item-checkbox-p)
      ;; Checkbox: Insert new item with checkbox.
      (org-insert-todo-heading nil))

     ((org-in-item-p)
      ;; Plain list.  Yes, this gets a little complicated...
      (let ((context (org-element-context)))
        (if (or (eq 'plain-list (car context))  ; First item in list
                (and (eq 'item (car context))
                     (not (eq (org-element-property :contents-begin context)
                              (org-element-property :contents-end context))))
                (unpackaged/org-element-descendant-of 'item context))  ; Element in list item, e.g. a link
            ;; Non-empty item: Add new item.
            (org-insert-item)
          ;; Empty item: Close the list.
          ;; TODO: Do this with org functions rather than operating on the text. Can't seem to find the right function.
          (delete-region (line-beginning-position) (line-end-position))
          (insert "\n"))))

     ((when (fboundp 'org-inlinetask-in-task-p)
        (org-inlinetask-in-task-p))
      ;; Inline task: Don't insert a new heading.
      (org-return t))

     ((org-at-table-p)
      (cond ((save-excursion
               (beginning-of-line)
               ;; See `org-table-next-field'.
               (cl-loop with end = (line-end-position)
                        for cell = (org-element-table-cell-parser)
                        always (equal (org-element-property :contents-begin cell)
                                      (org-element-property :contents-end cell))
                        while (re-search-forward "|" end t)))
             ;; Empty row: end the table.
             (delete-region (line-beginning-position) (line-end-position))
             (org-return t))
            (t
             ;; Non-empty row: call `org-return-indent'.
             (org-return t))))
     (t
      ;; All other cases: call `org-return-indent'.
      (org-return t)))))

(map!
 :after evil-org
 :map evil-org-mode-map
 :i [return] #'unpackaged/org-return-dwim)
#+end_src

**** Snippet Helpers

I often want to set =src-block= headers, and it's a pain to
+ type them out
+ remember what the accepted values are
+ oh, and specifying the same language again and again

We can solve this in three steps
+ having one-letter snippets, conditioned on ~(point)~ being within a src header
+ creating a nice prompt showing accepted values and the current default
+ pre-filling the =src-block= language with the last language used

For header args, the keys I'll use are
+ =r= for =:results=
+ =e= for =:exports=
+ =v= for =:eval=
+ =s= for =:session=
+ =d= for =:dir=

#+begin_src emacs-lisp
(defun +yas/org-src-header-p ()
  "Determine whether `point' is within a src-block header or header-args."
  (pcase (org-element-type (org-element-context))
    ('src-block (< (point) ; before code part of the src-block
                   (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                   (forward-line 1)
                                   (point))))
    ('inline-src-block (< (point) ; before code part of the inline-src-block
                          (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                          (search-forward "]{")
                                          (point))))
    ('keyword (string-match-p "^header-args" (org-element-property :value (org-element-context))))))
#+end_src

Now let's write a function we can reference in yasnippets to produce a nice
interactive way to specify header args.

#+begin_src emacs-lisp
(defun +yas/org-prompt-header-arg (arg question values)
  "Prompt the user to set ARG header property to one of VALUES with QUESTION.
The default value is identified and indicated. If either default is selected,
or no selection is made: nil is returned."
  (let* ((src-block-p (not (looking-back "^#\\+property:[ \t]+header-args:.*" (line-beginning-position))))
         (default
           (or
            (cdr (assoc arg
                        (if src-block-p
                            (nth 2 (org-babel-get-src-block-info t))
                          (org-babel-merge-params
                           org-babel-default-header-args
                           (let ((lang-headers
                                  (intern (concat "org-babel-default-header-args:"
                                                  (+yas/org-src-lang)))))
                             (when (boundp lang-headers) (eval lang-headers t)))))))
            ""))
         default-value)
    (setq values (mapcar
                  (lambda (value)
                    (if (string-match-p (regexp-quote value) default)
                        (setq default-value
                              (concat value " "
                                      (propertize "(default)" 'face 'font-lock-doc-face)))
                      value))
                  values))
    (let ((selection (consult--read values :prompt question :default default-value)))
      (unless (or (string-match-p "(default)$" selection)
                  (string= "" selection))
        selection))))
#+end_src

Finally, we fetch the language information for new source blocks.

Since we're getting this info, we might as well go a step further and also
provide the ability to determine the most popular language in the buffer that
doesn't have any =header-args= set for it (with =#+properties=).

#+begin_src emacs-lisp
(defun +yas/org-src-lang ()
  "Try to find the current language of the src/header at `point'.
Return nil otherwise."
  (let ((context (org-element-context)))
    (pcase (org-element-type context)
      ('src-block (org-element-property :language context))
      ('inline-src-block (org-element-property :language context))
      ('keyword (when (string-match "^header-args:\\([^ ]+\\)" (org-element-property :value context))
                  (match-string 1 (org-element-property :value context)))))))

(defun +yas/org-last-src-lang ()
  "Return the language of the last src-block, if it exists."
  (save-excursion
    (beginning-of-line)
    (when (re-search-backward "^[ \t]*#\\+begin_src" nil t)
      (org-element-property :language (org-element-context)))))

(defun +yas/org-most-common-no-property-lang ()
  "Find the lang with the most source blocks that has no global header-args, else nil."
  (let (src-langs header-langs)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+begin_src" nil t)
        (push (+yas/org-src-lang) src-langs))
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+property: +header-args" nil t)
        (push (+yas/org-src-lang) header-langs)))

    (setq src-langs
          (mapcar #'car
                  ;; sort alist by frequency (desc.)
                  (sort
                   ;; generate alist with form (value . frequency)
                   (cl-loop for (n . m) in (seq-group-by #'identity src-langs)
                            collect (cons n (length m)))
                   (lambda (a b) (> (cdr a) (cdr b))))))

    (car (cl-set-difference src-langs header-langs :test #'string=))))
#+end_src

**** Extra links

***** YouTube

The ~[[yt:...]]~ links preview nicely, but don't export nicely. Thankfully, we can
fix that.
#+begin_src emacs-lisp
(org-link-set-parameters "yt" :export #'+org-export-yt)
(defun +org-export-yt (path desc backend _com)
  (cond ((org-export-derived-backend-p backend 'html)
         (format "<iframe width='440' \
height='335' \
src='https://www.youtube.com/embed/%s' \
frameborder='0' \
allowfullscreen>%s</iframe>" path (or "" desc)))
        ((org-export-derived-backend-p backend 'latex)
         (format "\\href{https://youtu.be/%s}{%s}" path (or desc "youtube")))
        (t (format "https://youtu.be/%s" path))))
#+end_src

*** Visuals

#+call: confpkg("Org Visuals", after="org")

**** Font Display

I like my org to be pretty.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'+org-pretty-mode)
#+end_src

Also let's make headings a bit larger
#+begin_src emacs-lisp
(custom-set-faces!
  '(outline-1 :weight extra-bold :height 1.25)
  '(outline-2 :weight bold :height 1.15)
  '(outline-3 :weight bold :height 1.12)
  '(outline-4 :weight semi-bold :height 1.09)
  '(outline-5 :weight semi-bold :height 1.06)
  '(outline-6 :weight semi-bold :height 1.03)
  '(outline-8 :weight semi-bold)
  '(outline-9 :weight semi-bold))
#+end_src

And maybe titles, too
#+begin_src emacs-lisp
(custom-set-faces!
  '(org-document-title :height 1.2))
#+end_src

We can then have quote blocks stand out a bit more by making them /italic/.
#+begin_src emacs-lisp
(setq org-fontify-quote-and-verse-blocks t)
#+end_src

Org files can be rather nice to look at, particularly with some of the
customisations here. This comes at a cost however, expensive font-lock.
Feeling like you're typing through molasses in large files is no fun, but there
is a way I can defer font-locking when typing to make the experience more
responsive.
#+begin_src emacs-lisp
;;TODO: This can cause massive issues for some people. Check if I'm affected.
(defun locally-defer-font-lock ()
  "Set jit-lock defer and stealth, when buffer is over a certain size."
  (when (> (buffer-size) 50000)
    (setq-local jit-lock-defer-time 0.05
                jit-lock-stealth-time 1)))

(add-hook 'org-mode-hook #'locally-defer-font-lock)
#+end_src

**** Reduce Indentation

Due to some of the previous adjustments, anything that isn't a heading will feel overly indentend.
We can easily fix that.
This also has some fixes for ~mixed-pitch-mode~.

#+begin_src emacs-lisp
(defadvice! +org-indent--reduced-text-prefixes ()
  :after #'org-indent--compute-prefixes
  (setq org-indent--text-line-prefixes
        (make-vector org-indent--deepest-level nil))
  (when (> org-indent-indentation-per-level 0)
    (dotimes (n org-indent--deepest-level)
      (aset org-indent--text-line-prefixes
            n
            (org-add-props
                (concat (make-string (* n (1- org-indent-indentation-per-level))
                                     ?\s)
                        (if (> n 0)
                             (char-to-string org-indent-boundary-char)
                          "\u200b"))
                nil 'face 'org-indent)))))
#+end_src

**** Symbols

It's also nice to change the character used for collapsed items (by default ~â¦~),
I think ~â¾~ is better for indicating 'collapsed section'.
and add an extra ~org-bullet~ to the default list of four.

#+begin_src emacs-lisp
(setq org-ellipsis " â¾ "
      org-hide-leading-stars t
      org-priority-highest ?A
      org-priority-lowest ?E
      org-priority-faces
      '((?A . 'nerd-icons-red)
        (?B . 'nerd-icons-orange)
        (?C . 'nerd-icons-yellow)
        (?D . 'nerd-icons-green)
        (?E . 'nerd-icons-blue)))
#+end_src

It's also nice to make use of the =prettify-symbols-mode= for a few Org syntactic
tokens which we'd like to prettify that aren't covered by =org-modern= or any
other settings.

#+begin_src emacs-lisp
(defadvice! +org-init-appearance-h--no-ligatures-a ()
  :after #'+org-init-appearance-h
  (set-ligatures! 'org-mode nil)
  (set-ligatures! 'org-mode
    :list_property "::"
    :em_dash       "---"
    :ellipsis      "..."
    :arrow_right   "->"
    :arrow_left    "<-"
    :arrow_lr      "<->"
    :properties    ":PROPERTIES:"
    :end           ":END:"
    :priority_a    "[#A]"
    :priority_b    "[#B]"
    :priority_c    "[#C]"
    :priority_d    "[#D]"
    :priority_e    "[#E]"))
#+end_src

**** LaTeX Fragments
***** Prettier highlighting

First off, we want those fragments to look good.
#+begin_src emacs-lisp
(setq org-highlight-latex-and-related '(native script entities))
#+end_src

However, by using =native= highlighting the =org-block= face is added, and that
doesn't look too great --- particularly when the fragments are previewed.

Ideally ~org-src-font-lock-fontify-block~ wouldn't add the =org-block= face, but we
can avoid advising that entire function by just adding another face with
=:inherit default= which will override the background colour.

Inspecting ~org-do-latex-and-related~ shows that ="latex"= is the language argument
passed, and so we can override the background as discussed above.
#+begin_src emacs-lisp
(require 'org-src)
(add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t)))
#+end_src

***** Automatic previewing

It would be nice if fragments could automatically be previewed after being
typed, and the overlays automatically showed and hidden when moving the point in
and out of the LaTeX fragments.

Thankfully, all we need to do to make this happen is use ~org-latex-preview-auto-mode~.

#+begin_src emacs-lisp
;; TODO: This seems to break stuff, notably: Fancy heading points
;;(add-hook 'org-mode-hook #'org-latex-preview-auto-mode)
#+end_src

***** Prettier rendering

It's nice to customise the look of LaTeX fragments so they fit better in the
text --- like this \(\sqrt{\beta^2+3}-\sum_{\phi=1}^\infty \frac{x^\phi-1}{\Gamma(a)}\).

The default snippet preamble basically just sets the margins and text size, with
templates to be filled in by ~org-latex-default-packages-alist~ and
=#+latex_header:= entries (but not =#+latex_header_extra:=).

#+name: latex-default-snippet-preamble
#+begin_src LaTeX
\documentclass{article}
[DEFAULT-PACKAGES]
[PACKAGES]
\usepackage{xcolor}
#+end_src

To this, we make two additions:
+ Selection of a maths font that fits better with displayed text.

#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
(setq org-latex-preview-header
      (concat
       <<grab("latex-default-snippet-preamble")>>
       "\n% Custom font\n\\usepackage{arev}\n\n"
       <<grab("latex-maths-conveniences")>>))
#+end_src

Since we can, instead of making the background colour match the =default= face,
let's make it transparent.

#+begin_src emacs-lisp
(plist-put org-format-latex-options :background "Transparent")
(plist-put org-format-latex-options :zoom 0.93) ; Calibrated based on the TeX font and org-buffer font.
#+end_src

With the background taken care of, we just need to make sure we're using the
theme-appropriate foreground.

#+begin_src emacs-lisp
(defun +org-refresh-latex-images-previews-h ()
  (dolist (buffer (doom-buffers-in-mode 'org-mode (buffer-list)))
    (with-current-buffer buffer
      (+org--toggle-inline-images-in-subtree (point-min) (point-max) 'refresh)
      (unless (eq org-latex-preview-default-process 'dvisvgm)
        (org-clear-latex-preview (point-min) (point-max))
        (org--latex-preview-region (point-min) (point-max))))))

(add-hook 'doom-load-theme-hook #'+org-refresh-latex-images-previews-h)
#+end_src

**** Org Plot

We can use some of the variables in =org-plot= to use the current doom theme
colours.
#+begin_src emacs-lisp
(defvar +org-plot-term-size '(1050 . 650)
  "The size of the GNUPlot terminal, in the form (WIDTH . HEIGHT).")

(after! org-plot
  (defun +org-plot-generate-theme (_type)
    "Use the current Doom theme colours to generate a GnuPlot preamble."
    (format "
fgt = \"textcolor rgb '%s'\" # foreground text
fgat = \"textcolor rgb '%s'\" # foreground alt text
fgl = \"linecolor rgb '%s'\" # foreground line
fgal = \"linecolor rgb '%s'\" # foreground alt line

# foreground colors
set border lc rgb '%s'
# change text colors of  tics
set xtics @fgt
set ytics @fgt
# change text colors of labels
set title @fgt
set xlabel @fgt
set ylabel @fgt
# change a text color of key
set key @fgt

# line styles
set linetype 1 lw 2 lc rgb '%s' # red
set linetype 2 lw 2 lc rgb '%s' # blue
set linetype 3 lw 2 lc rgb '%s' # green
set linetype 4 lw 2 lc rgb '%s' # magenta
set linetype 5 lw 2 lc rgb '%s' # orange
set linetype 6 lw 2 lc rgb '%s' # yellow
set linetype 7 lw 2 lc rgb '%s' # teal
set linetype 8 lw 2 lc rgb '%s' # violet

# border styles
set tics out nomirror
set border 3

# palette
set palette maxcolors 8
set palette defined ( 0 '%s',\
1 '%s',\
2 '%s',\
3 '%s',\
4 '%s',\
5 '%s',\
6 '%s',\
7 '%s' )
"
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            ;; colours
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ;; duplicated
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)))

  (defun +org-plot-gnuplot-term-properties (_type)
    (format "background rgb '%s' size %s,%s"
            (doom-color 'bg) (car +org-plot-term-size) (cdr +org-plot-term-size)))

  (setq org-plot/gnuplot-script-preamble #'+org-plot-generate-theme)
  (setq org-plot/gnuplot-term-extra #'+org-plot-gnuplot-term-properties))
#+end_src

*** Exporting

#+call: confpkg("Org exports", after="ox")

**** General settings

By default Org only exports the first three levels of headings as ... headings.
This is rather unfortunate as my documents frequently stray far beyond three
levels of depth. The two main formats I care about exporting to are LaTeX and
HTML. When using an =article= class, LaTeX headlines go from =\section=,
=\subsection=, =\subsubsection=, and =\paragraph= to =\subgraph= --- /five/ levels.
HTML5 has six levels of headings (=<h1>= to =<h6>=), but first level Org headings
get exported as =<h2>= elements --- leaving /five/ usable levels.

As such, it would seem to make sense to recognise the first /five/ levels of Org
headings when exporting.

#+begin_src emacs-lisp
(setq org-export-headline-levels 5) ; I like nesting
#+end_src

I'm also going to make use of an item in =ox-extra= so that I can add an =:ignore:=
tag to headings for the content to be kept, but the heading itself ignored
(unlike =:noexport:= which ignored both heading and content). This is useful when
I want to use headings to provide a structure for writing that doesn't appear in
the final documents.
#+begin_src emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+end_src

**** Acronym formatting

I like automatically using spaced small caps for acronyms. For strings I want to
be unaffected let's use ~;~ as a prefix to prevent the transformation --- i.e.
~;JFK~ (as one would want for two-letter geographic locations and names).

This has to be implemented on a per-format basis, currently HTML and LaTeX
exports are supported.

#+begin_src emacs-lisp
(defun org-export-filter-text-acronym (text backend _info)
  "Wrap suspected acronyms in acronyms-specific formatting.
Treat sequences of 2+ capital letters (optionally succeeded by \"s\") as an acronym.
Ignore if preceeded by \";\" (for manual prevention) or \"\\\" (for LaTeX commands).

TODO abstract backend implementations."
  (let ((base-backend
         (cond
          ((org-export-derived-backend-p backend 'latex) 'latex)
          ;; Markdown is derived from HTML, but we don't want to format it
          ((org-export-derived-backend-p backend 'md) nil)
          ((org-export-derived-backend-p backend 'html) 'html)))
        (case-fold-search nil))
    (when base-backend
      (replace-regexp-in-string
       "[;\\\\]?\\b[A-Z][A-Z]+s?\\(?:[^A-Za-z]\\|\\b\\)"
       (lambda (all-caps-str)
         (cond ((equal (aref all-caps-str 0) ?\\) all-caps-str)                ; don't format LaTeX commands
               ((equal (aref all-caps-str 0) ?\;) (substring all-caps-str 1))  ; just remove not-acronym indicator char ";"
               (t (let* ((final-char (if (string-match-p "[^A-Za-z]" (substring all-caps-str -1 (length all-caps-str)))
                                         (substring all-caps-str -1 (length all-caps-str))
                                       nil)) ; needed to re-insert the [^A-Za-z] at the end
                         (trailing-s (equal (aref all-caps-str (- (length all-caps-str) (if final-char 2 1))) ?s))
                         (acr (if final-char
                                  (substring all-caps-str 0 (if trailing-s -2 -1))
                                (substring all-caps-str 0 (+ (if trailing-s -1 (length all-caps-str)))))))
                    (pcase base-backend
                      ('latex (concat "\\acr{" (s-downcase acr) "}" (when trailing-s "\\acrs{}") final-char))
                      ('html (concat "<span class='acr'>" acr "</span>" (when trailing-s "<small>s</small>") final-char)))))))
       text t t))))

(add-to-list 'org-export-filter-plain-text-functions
             #'org-export-filter-text-acronym)

;; We won't use `org-export-filter-headline-functions' because it
;; passes (and formats) the entire section contents. That's no good.

(defun org-html-format-headline-acronymised (todo todo-type priority text tags info)
  "Like `org-html-format-headline-default-function', but with acronym formatting."
  (org-html-format-headline-default-function
   todo todo-type priority (org-export-filter-text-acronym text 'html info) tags info))
(setq org-html-format-headline-function #'org-html-format-headline-acronymised)

(defun org-latex-format-headline-acronymised (todo todo-type priority text tags info)
  "Like `org-latex-format-headline-default-function', but with acronym formatting."
  (org-latex-format-headline-default-function
   todo todo-type priority (org-export-filter-text-acronym text 'latex info) tags info))
(setq org-latex-format-headline-function #'org-latex-format-headline-acronymised)
#+end_src

**** Exporting Org code

With all our Org config and hooks, exporting an Org code block when using
a font-lock based method can produce undesirable results. To address this, we
can tweak ~+org-babel-mode-alist~ when exporting.

#+begin_src emacs-lisp
(defun +org-mode--fontlock-only-mode ()
  "Just apply org-mode's font-lock once."
  (let (org-mode-hook
        org-hide-leading-stars
        org-hide-emphasis-markers)
    (org-set-font-lock-defaults)
    (font-lock-ensure))
  (setq-local major-mode #'fundamental-mode))

(defun +org-export-babel-mask-org-config (_backend)
  "Use `+org-mode--fontlock-only-mode' instead of `org-mode'."
  (setq-local org-src-lang-modes
              (append org-src-lang-modes
                      (list (cons "org" #'+org-mode--fontlock-only)))))

(add-hook 'org-export-before-processing-hook #'+org-export-babel-mask-org-config)
#+end_src

*** HTML Export

#+call: confpkg("ox-html", after="ox-html")

Like most of this config, HTML exports are supposed to look good.
That said, overly intricate setups make debugging difficult and since proper
planning prevents poor performance, I will save myself the hassle of having to
deal with any of that by simply putting my fancy-exporting into an
enabled-by-default ~minor-mode~.

#+begin_src emacs-lisp
(define-minor-mode org-fancy-html-export-mode
  "Toggle my fabulous org export tweaks. While this mode itself does a little bit,
the vast majority of the change in behaviour comes from switch statements in:
 - `org-html-template-fancier'
 - `org-html--build-meta-info-extended'
 - `org-html-src-block-collapsable'
 - `org-html-block-collapsable'
 - `org-html-table-wrapped'
 - `org-html--format-toc-headline-colapseable'
 - `org-html--toc-text-stripped-leaves'
 - `org-export-html-headline-anchor'"
  :global t
  :init-value t
  (if org-fancy-html-export-mode
      (setq org-html-style-default org-html-style-fancy
            org-html-meta-tags #'org-html-meta-tags-fancy
            org-html-checkbox-type 'html-span)
    (setq org-html-style-default org-html-style-plain
          org-html-meta-tags #'org-html-meta-tags-default
          org-html-checkbox-type 'html)))
#+end_src

**** Extra header content

We want to tack on a few more bits to the start of the body. Unfortunately, there
doesn't seem to be any nice variable or hook, so we'll just override the
relevant function.

This is done to allow me to add the date and author to the page header,
implement a CSS-only light/dark theme toggle, and a sprinkle of [[https://ogp.me/][Open Graph]]
metadata.
#+begin_src emacs-lisp
(defadvice! org-html-template-fancier (orig-fn contents info)
  "Return complete document string after HTML conversion.
CONTENTS is the transcoded contents string.  INFO is a plist
holding export options. Adds a few extra things to the body
compared to the default implementation."
  :around #'org-html-template
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn contents info)
    (concat
     (when (and (not (org-html-html5-p info)) (org-html-xhtml-p info))
       (let* ((xml-declaration (plist-get info :html-xml-declaration))
              (decl (or (and (stringp xml-declaration) xml-declaration)
                        (cdr (assoc (plist-get info :html-extension)
                                    xml-declaration))
                        (cdr (assoc "html" xml-declaration))
                        "")))
         (when (not (or (not decl) (string= "" decl)))
           (format "%s\n"
                   (format decl
                           (or (and org-html-coding-system
                                    (fboundp 'coding-system-get)
                                    (coding-system-get org-html-coding-system 'mime-charset))
                               "iso-8859-1"))))))
     (org-html-doctype info)
     "\n"
     (concat "<html"
             (cond ((org-html-xhtml-p info)
                    (format
                     " xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"%s\" xml:lang=\"%s\""
                     (plist-get info :language) (plist-get info :language)))
                   ((org-html-html5-p info)
                    (format " lang=\"%s\"" (plist-get info :language))))
             ">\n")
     "<head>\n"
     (org-html--build-meta-info info)
     (org-html--build-head info)
     (org-html--build-mathjax-config info)
     "</head>\n"
     "<body>\n<input type='checkbox' id='theme-switch'><div id='page'><label id='switch-label' for='theme-switch'></label>"
     (let ((link-up (org-trim (plist-get info :html-link-up)))
           (link-home (org-trim (plist-get info :html-link-home))))
       (unless (and (string= link-up "") (string= link-home ""))
         (format (plist-get info :html-home/up-format)
                 (or link-up link-home)
                 (or link-home link-up))))
     ;; Preamble.
     (org-html--build-pre/postamble 'preamble info)
     ;; Document contents.
     (let ((div (assq 'content (plist-get info :html-divs))))
       (format "<%s id=\"%s\">\n" (nth 1 div) (nth 2 div)))
     ;; Document title.
     (when (plist-get info :with-title)
       (let ((title (and (plist-get info :with-title)
                         (plist-get info :title)))
             (subtitle (plist-get info :subtitle))
             (html5-fancy (org-html--html5-fancy-p info)))
         (when title
           (format
            (if html5-fancy
                "<header class=\"page-header\">%s\n<h1 class=\"title\">%s</h1>\n%s</header>"
              "<h1 class=\"title\">%s%s</h1>\n")
            (if (or (plist-get info :with-date)
                    (plist-get info :with-author))
                (concat "<div class=\"page-meta\">"
                        (when (plist-get info :with-date)
                          (org-export-data (plist-get info :date) info))
                        (when (and (plist-get info :with-date) (plist-get info :with-author)) ", ")
                        (when (plist-get info :with-author)
                          (org-export-data (plist-get info :author) info))
                        "</div>\n")
              "")
            (org-export-data title info)
            (if subtitle
                (format
                 (if html5-fancy
                     "<p class=\"subtitle\" role=\"doc-subtitle\">%s</p>\n"
                   (concat "\n" (org-html-close-tag "br" nil info) "\n"
                           "<span class=\"subtitle\">%s</span>\n"))
                 (org-export-data subtitle info))
              "")))))
     contents
     (format "</%s>\n" (nth 1 (assq 'content (plist-get info :html-divs))))
     ;; Postamble.
     (org-html--build-pre/postamble 'postamble info)
     ;; Possibly use the Klipse library live code blocks.
     (when (plist-get info :html-klipsify-src)
       (concat "<script>" (plist-get info :html-klipse-selection-script)
               "</script><script src=\""
               org-html-klipse-js
               "\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\""
               org-html-klipse-css "\"/>"))
     ;; Closing document.
     "</div>\n</body>\n</html>")))
#+end_src

I think it would be nice if "Table of Contents" brought you back to the top of
the page. Well, since we've done this much advising already...
#+begin_src emacs-lisp
(defadvice! org-html-toc-linked (depth info &optional scope)
  "Build a table of contents.

Just like `org-html-toc', except the header is a link to \"#\".

DEPTH is an integer specifying the depth of the table.  INFO is
a plist used as a communication channel.  Optional argument SCOPE
is an element defining the scope of the table.  Return the table
of contents as a string, or nil if it is empty."
  :override #'org-html-toc
  (let ((toc-entries
         (mapcar (lambda (headline)
                   (cons (org-html--format-toc-headline headline info)
                         (org-export-get-relative-level headline info)))
                 (org-export-collect-headlines info depth scope))))
    (when toc-entries
      (let ((toc (concat "<div id=\"text-table-of-contents\">"
                         (org-html--toc-text toc-entries)
                         "</div>\n")))
        (if scope toc
          (let ((outer-tag (if (org-html--html5-fancy-p info)
                               "nav"
                             "div")))
            (concat (format "<%s id=\"table-of-contents\">\n" outer-tag)
                    (let ((top-level (plist-get info :html-toplevel-hlevel)))
                      (format "<h%d><a href=\"#\" style=\"color:inherit; text-decoration: none;\">%s</a></h%d>\n"
                              top-level
                              (org-html--translate "Table of Contents" info)
                              top-level))
                    toc
                    (format "</%s>\n" outer-tag))))))))
#+end_src

Lastly, let's pile on some metadata. This gives my pages nice embeds.
#+begin_src emacs-lisp
(defvar org-html-meta-tags-opengraph-image
  '(:image "https://sold.rip/stylized_o.png"
    :type "image/png"
    :width "200"
    :height "200"
    :alt "White o with line")
  "Plist of og:image:PROP properties and their value, for use in `org-html-meta-tags-fancy'.")

(defun org-html-meta-tags-fancy (info)
  "Use the INFO plist to construct the meta tags, as described in `org-html-meta-tags'."
  (let ((title (org-html-plain-text
                (org-element-interpret-data (plist-get info :title)) info))
        (author (and (plist-get info :with-author)
                     (let ((auth (plist-get info :author)))
                       ;; Return raw Org syntax.
                       (and auth (org-html-plain-text
                                  (org-element-interpret-data auth) info))))))
    (append
     (list
      (when (org-string-nw-p author)
        (list "name" "author" author))
      (when (org-string-nw-p (plist-get info :description))
        (list "name" "description"
              (plist-get info :description)))
      '("name" "generator" "org mode")
      '("name" "theme-color" "#77aa99")
      '("property" "og:type" "article")
      (list "property" "og:title" title)
      (let ((subtitle (org-export-data (plist-get info :subtitle) info)))
        (when (org-string-nw-p subtitle)
          (list "property" "og:description" subtitle))))
     (when org-html-meta-tags-opengraph-image
       (list (list "property" "og:image" (plist-get org-html-meta-tags-opengraph-image :image))
             (list "property" "og:image:type" (plist-get org-html-meta-tags-opengraph-image :type))
             (list "property" "og:image:width" (plist-get org-html-meta-tags-opengraph-image :width))
             (list "property" "og:image:height" (plist-get org-html-meta-tags-opengraph-image :height))
             (list "property" "og:image:alt" (plist-get org-html-meta-tags-opengraph-image :alt))))
     (list
      (when (org-string-nw-p author)
        (list "property" "og:article:author:first_name" (car (s-split-up-to " " author 2))))
      (when (and (org-string-nw-p author) (s-contains-p " " author))
        (list "property" "og:article:author:last_name" (cadr (s-split-up-to " " author 2))))
      (list "property" "og:article:published_time"
            (format-time-string
             "%FT%T%z"
             (or
              (when-let ((date-str (cadar (org-collect-keywords '("DATE")))))
                (unless (string= date-str (format-time-string "%F"))
                  (ignore-errors (encode-time (org-parse-time-string date-str)))))
              (if buffer-file-name
                  (file-attribute-modification-time (file-attributes buffer-file-name))
                (current-time)))))
      (when buffer-file-name
        (list "property" "og:article:modified_time"
              (format-time-string "%FT%T%z" (file-attribute-modification-time (file-attributes buffer-file-name)))))))))

(unless (functionp #'org-html-meta-tags-default)
  (defalias 'org-html-meta-tags-default #'ignore))
(setq org-html-meta-tags #'org-html-meta-tags-fancy)
#+end_src

**** Custom CSS/JS

The default org HTML export is ... alright, but we can really jazz it up.
[[https://lepisma.xyz][lepisma.xyz]] has a really nice style, and from and org export too!
Suffice to say I've snatched it, with a few of my own tweaks applied.

#+begin_src html :tangle misc/org-export-header.html :comments no
<link rel="icon" href="https://sold.rip/stylized_o.png" type="image/ico" />

<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/etbookot-roman-webfont.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/etbookot-italic-webfont.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/Merriweather-TextRegular.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/Merriweather-TextItalic.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/Merriweather-TextBold.woff2">
#+end_src

#+begin_src emacs-lisp
(setq org-html-style-plain org-html-style-default
      org-html-htmlize-output-type 'css
      org-html-doctype "html5"
      org-html-html5-fancy t)

(defun org-html-reload-fancy-style ()
  (interactive)
  (setq org-html-style-fancy
        (concat (f-read-text (expand-file-name "misc/org-export-header.html" doom-private-dir))
                "<script>\n"
                (f-read-text (expand-file-name "misc/org-css/main.js" doom-private-dir))
                "</script>\n<style>\n"
                (f-read-text (expand-file-name "misc/org-css/main.min.css" doom-private-dir))
                "</style>"))
  (when org-fancy-html-export-mode
    (setq org-html-style-default org-html-style-fancy)))
(org-html-reload-fancy-style)
#+end_src

**** Collapsable src and example blocks

By wrapping the ~<pre>~ element in a ~<details>~ block, we can obtain collapsable
blocks with no CSS, though we will toss a little in anyway to have this looking
somewhat spiffy.

Since this collapsability seems useful to have on by default for certain chunks
of code, it would be nice if you could set it with =#+attr_html: :collapsed t=.

It would be nice to also have a corresponding global / session-local way of
setting this, but I haven't quite been able to get that working (yet).

#+begin_src emacs-lisp
(defvar org-html-export-collapsed nil)
(eval '(cl-pushnew '(:collapsed "COLLAPSED" "collapsed" org-html-export-collapsed t)
                   (org-export-backend-options (org-export-get-backend 'html))))
(add-to-list 'org-default-properties "EXPORT_COLLAPSED")
#+end_src

We can take our src block modification a step further, and add a gutter on the
side of the src block containing both an anchor referencing the current block,
and a button to copy the content of the block.

#+name: Src blocks
#+begin_src emacs-lisp
(defadvice! org-html-src-block-collapsable (orig-fn src-block contents info)
  "Wrap the usual <pre> block in a <details>"
  :around #'org-html-src-block
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn src-block contents info)
    (let* ((properties (cadr src-block))
           (lang (mode-name-to-lang-name
                  (plist-get properties :language)))
           (name (plist-get properties :name))
           (ref (org-export-get-reference src-block info))
           (collapsed-p (member (or (org-export-read-attribute :attr_html src-block :collapsed)
                                    (plist-get info :collapsed))
                                '("y" "yes" "t" t "true" "all"))))
      (format
       "<details id='%s' class='code'%s><summary%s>%s</summary>
<div class='gutter'>
<a href='#%s'>#</a>
<button title='Copy to clipboard' onclick='copyPreToClipbord(this)'>â</button>\
</div>
%s
</details>"
       ref
       (if collapsed-p "" " open")
       (if name " class='named'" "")
       (concat
        (when name (concat "<span class=\"name\">" name "</span>"))
        "<span class=\"lang\">" lang "</span>")
       ref
       (if name
           (replace-regexp-in-string (format "<pre\\( class=\"[^\"]+\"\\)? id=\"%s\">" ref) "<pre\\1>"
                                     (funcall orig-fn src-block contents info))
         (funcall orig-fn src-block contents info))))))

(defun mode-name-to-lang-name (mode)
  (or (cadr (assoc mode
                   '(("asymptote" "Asymptote")
                     ("awk" "Awk")
                     ("C" "C")
                     ("clojure" "Clojure")
                     ("css" "CSS")
                     ("D" "D")
                     ("ditaa" "ditaa")
                     ("dot" "Graphviz")
                     ("calc" "Emacs Calc")
                     ("emacs-lisp" "Emacs Lisp")
                     ("fortran" "Fortran")
                     ("gnuplot" "gnuplot")
                     ("haskell" "Haskell")
                     ("hledger" "hledger")
                     ("java" "Java")
                     ("js" "Javascript")
                     ("latex" "LaTeX")
                     ("ledger" "Ledger")
                     ("lisp" "Lisp")
                     ("lilypond" "Lilypond")
                     ("lua" "Lua")
                     ("matlab" "MATLAB")
                     ("mscgen" "Mscgen")
                     ("ocaml" "Objective Caml")
                     ("octave" "Octave")
                     ("org" "Org mode")
                     ("oz" "OZ")
                     ("plantuml" "Plantuml")
                     ("processing" "Processing.js")
                     ("python" "Python")
                     ("R" "R")
                     ("ruby" "Ruby")
                     ("sass" "Sass")
                     ("scheme" "Scheme")
                     ("screen" "Gnu Screen")
                     ("sed" "Sed")
                     ("sh" "shell")
                     ("sql" "SQL")
                     ("sqlite" "SQLite")
                     ("forth" "Forth")
                     ("io" "IO")
                     ("J" "J")
                     ("makefile" "Makefile")
                     ("maxima" "Maxima")
                     ("perl" "Perl")
                     ("picolisp" "Pico Lisp")
                     ("scala" "Scala")
                     ("shell" "Shell Script")
                     ("ebnf2ps" "ebfn2ps")
                     ("cpp" "C++")
                     ("abc" "ABC")
                     ("coq" "Coq")
                     ("groovy" "Groovy")
                     ("bash" "bash")
                     ("csh" "csh")
                     ("ash" "ash")
                     ("dash" "dash")
                     ("ksh" "ksh")
                     ("mksh" "mksh")
                     ("posh" "posh")
                     ("ada" "Ada")
                     ("asm" "Assembler")
                     ("caml" "Caml")
                     ("delphi" "Delphi")
                     ("html" "HTML")
                     ("idl" "IDL")
                     ("mercury" "Mercury")
                     ("metapost" "MetaPost")
                     ("modula-2" "Modula-2")
                     ("pascal" "Pascal")
                     ("ps" "PostScript")
                     ("prolog" "Prolog")
                     ("simula" "Simula")
                     ("tcl" "tcl")
                     ("tex" "LaTeX")
                     ("plain-tex" "TeX")
                     ("verilog" "Verilog")
                     ("vhdl" "VHDL")
                     ("xml" "XML")
                     ("nxml" "XML")
                     ("conf" "Configuration File"))))
      mode))
#+end_src

#+name: Example, fixed width, and property blocks
#+begin_src emacs-lisp
(defun org-html-block-collapsable (orig-fn block contents info)
  "Wrap the usual block in a <details>"
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn block contents info)
    (let ((ref (org-export-get-reference block info))
          (type (pcase (car block)
                  ('property-drawer "Properties")))
          (collapsed-default (pcase (car block)
                               ('property-drawer t)
                               (_ nil)))
          (collapsed-value (org-export-read-attribute :attr_html block :collapsed))
          (collapsed-p (or (member (org-export-read-attribute :attr_html block :collapsed)
                                   '("y" "yes" "t" t "true"))
                           (member (plist-get info :collapsed) '("all")))))
      (format
       "<details id='%s' class='code'%s>
<summary%s>%s</summary>
<div class='gutter'>\
<a href='#%s'>#</a>
<button title='Copy to clipboard' onclick='copyPreToClipbord(this)'>â</button>\
</div>
%s\n
</details>"
       ref
       (if (or collapsed-p collapsed-default) "" " open")
       (if type " class='named'" "")
       (if type (format "<span class='type'>%s</span>" type) "")
       ref
       (funcall orig-fn block contents info)))))

(advice-add 'org-html-example-block   :around #'org-html-block-collapsable)
(advice-add 'org-html-fixed-width     :around #'org-html-block-collapsable)
(advice-add 'org-html-property-drawer :around #'org-html-block-collapsable)
#+end_src

**** Include extra font-locking in htmlize

Org uses [[https://github.com/hniksic/emacs-htmlize][htmlize.el]] to export buffers with syntax highlighting.

The works fantastically, for the most part. Minor modes that provide
font-locking are /not/ loaded, and so do not impact the result.

By enabling these modes in ~htmlize-before-hook~ we can correct this behaviour.

#+begin_src emacs-lisp
(autoload #'highlight-numbers--turn-on "highlight-numbers")
(add-hook 'htmlize-before-hook #'highlight-numbers--turn-on)
#+end_src

**** Handle table overflow

In order to accommodate wide tables ---particularly on mobile devices--- we want
to set a maximum width and scroll overflow. Unfortunately, this cannot be applied
directly to the ~table~ element, so we have to wrap it in a ~div~.

While we're at it, we can a link gutter, as we did with src blocks, and show the
~#+name~, if one is given.

#+begin_src emacs-lisp
(defadvice! org-html-table-wrapped (orig-fn table contents info)
  "Wrap the usual <table> in a <div>"
  :around #'org-html-table
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn table contents info)
    (let* ((name (plist-get (cadr table) :name))
           (ref (org-export-get-reference table info)))
      (format "<div id='%s' class='table'>
<div class='gutter'><a href='#%s'>#</a></div>
<div class='tabular'>
%s
</div>\
</div>"
              ref ref
              (if name
                  (replace-regexp-in-string (format "<table id=\"%s\"" ref) "<table"
                                            (funcall orig-fn table contents info))
                (funcall orig-fn table contents info))))))
#+end_src

**** TOC as a collapsable tree

The TOC is much nicer to navigate as a collapsable tree. Unfortunately we cannot
achieve this with CSS alone. Thankfully we can avoid JS though, by adapting the
TOC generation code to use a ~label~ for each item, and a hidden ~checkbox~ to keep
track of state.

Since we can actually accomplish the desired effect by adding advice /around/ the
function, without overriding it --- let's do that to reduce the bug surface of
this config a tad.
#+begin_src emacs-lisp
(defadvice! org-html--format-toc-headline-colapseable (orig-fn headline info)
  "Add a label and checkbox to `org-html--format-toc-headline's usual output,
to allow the TOC to be a collapseable tree."
  :around #'org-html--format-toc-headline
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn headline info)
    (let ((id (or (org-element-property :CUSTOM_ID headline)
                  (org-export-get-reference headline info))))
      (format "<input type='checkbox' id='toc--%s'/><label for='toc--%s'>%s</label>"
              id id (funcall orig-fn headline info)))))
#+end_src

Now, leaves (headings with no children) shouldn't have the ~label~ item. The
obvious way to achieve this is by including some /if no children.../ logic in
~org-html--format-toc-headline-colapseable~. Unfortunately, I can't my elisp isn't
up to par to extract the number of child headings from the mountain of info that
org provides.
#+begin_src emacs-lisp
(defadvice! org-html--toc-text-stripped-leaves (orig-fn toc-entries)
  "Remove label"
  :around #'org-html--toc-text
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn toc-entries)
    (replace-regexp-in-string "<input [^>]+><label [^>]+>\\(.+?\\)</label></li>" "\\1</li>"
                              (funcall orig-fn toc-entries))))
#+end_src

**** Make verbatim different to code

Since we have =verbatim= and ~code~, let's make use of the difference.

We can use ~code~ exclusively for code snippets and commands like: "calling
src_elisp{(message "Hello")} in batch-mode Emacs prints to stdout like ~echo~".
Then we can use =verbatim= for miscellaneous 'other monospace' like keyboard
shortcuts: "either =C-c C-c= or =C-g= is likely the most useful keybinding in Emacs",
or file names: "I keep my configuration in =~/.config/doom/=", among other things.

Then, styling these two cases differently can help improve clarity in a document.

#+begin_src emacs-lisp
(setq org-html-text-markup-alist
      '((bold . "<b>%s</b>")
        (code . "<code>%s</code>")
        (italic . "<i>%s</i>")
        (strike-through . "<del>%s</del>")
        (underline . "<span class=\"underline\">%s</span>")
        (verbatim . "<kbd>%s</kbd>")))
#+end_src

**** Change checkbox type

We also want to use HTML checkboxes, however we want to get a bit fancier than default
#+begin_src emacs-lisp
(appendq! org-html-checkbox-types
          '((html-span
             (on . "<span class='checkbox'></span>")
             (off . "<span class='checkbox'></span>")
             (trans . "<span class='checkbox'></span>"))))
(setq org-html-checkbox-type 'html-span)
#+end_src
- [ ] I'm yet to do this
- [-] Work in progress
- [X] This is done

**** Extra special strings

The ~org-html-special-string-regexps~ variable defines substitutions for:
+ =\-=, a shy hyphen
+ =---=, an em dash
+ =--=, an en dash
+ =...=, (horizontal) ellipses

However I think it would be nice if there was also a substitution for left/right
arrows (=->= and =<-=). This is a ~defconst~, but as you may tell from the amount of
advice in this config, I'm not above messing with things I'm not 'supposed' to.

The only minor complication is that =<= and =>= are converted to =&lt;= and =&gt;=
before this stage of output processing.

#+begin_src emacs-lisp
(pushnew! org-html-special-string-regexps
          '("-&gt;" . "&#8594;")
          '("&lt;-" . "&#8592;"))
#+end_src

**** Header anchors

I want to add GitHub-style links on hover for headings.
#+begin_src emacs-lisp
(defun org-export-html-headline-anchor (text backend info)
  (when (and (org-export-derived-backend-p backend 'html)
             (not (org-export-derived-backend-p backend 're-reveal))
             org-fancy-html-export-mode)
    (unless (bound-and-true-p org-msg-export-in-progress)
      (replace-regexp-in-string
       "<h\\([0-9]\\) id=\"\\([a-z0-9-]+\\)\">\\(.*[^ ]\\)<\\/h[0-9]>" ; this is quite restrictive, but due to `org-reference-contraction' I can do this
       "<h\\1 id=\"\\2\">\\3<a aria-hidden=\"true\" href=\"#\\2\">#</a> </h\\1>"
       text))))

(add-to-list 'org-export-filter-headline-functions
             'org-export-html-headline-anchor)
#+end_src

**** Link previews

Sometimes it's nice to make a link particularly prominent, an embed/preview like
Twitter does would be nice I think.

We can do this without too much trouble by adding a new link type ever so
slightly different from =https= --- =Https=.

#+begin_src emacs-lisp
(org-link-set-parameters "Https"
                         :follow (lambda (url arg) (browse-url (concat "https:" url) arg))
                         :export #'org-url-fancy-export)
#+end_src

Then, if we can fetch a plist of the form src_elisp{(:title "..." :description
"..." :image "...")} for such links via a function ~org-url-unfurl-metadata~, we
can make a fancy export.

#+begin_src emacs-lisp
(defun org-url-fancy-export (url _desc backend)
  (let ((metadata (org-url-unfurl-metadata (concat "https:" url))))
    (cond
     ((org-export-derived-backend-p backend 'html)
      (concat
       "<div class=\"link-preview\">"
       (format "<a href=\"%s\">" (concat "https:" url))
       (when (plist-get metadata :image)
         (format "<img src=\"%s\"/>" (plist-get metadata :image)))
       "<small>"
       (replace-regexp-in-string "//\\(?:www\\.\\)?\\([^/]+\\)/?.*" "\\1" url)
       "</small><p>"
       (when (plist-get metadata :title)
         (concat "<b>" (org-html-encode-plain-text (plist-get metadata :title)) "</b></br>"))
       (when (plist-get metadata :description)
         (org-html-encode-plain-text (plist-get metadata :description)))
       "</p></a></div>"))
     (t url))))
#+end_src

Now we just need to actually implement that metadata extraction function.
#+begin_src emacs-lisp
(setq org-url-unfurl-metadata--cache nil)
(defun org-url-unfurl-metadata (url)
  (cdr (or (assoc url org-url-unfurl-metadata--cache)
           (car (push
                 (cons
                  url
                  (let* ((head-data
                          (-filter #'listp
                                   (cdaddr
                                    (with-current-buffer (progn (message "Fetching metadata from %s" url)
                                                                (url-retrieve-synchronously url t t 5))
                                      (goto-char (point-min))
                                      (delete-region (point-min) (- (search-forward "<head") 6))
                                      (delete-region (search-forward "</head>") (point-max))
                                      (goto-char (point-min))
                                      (while (re-search-forward "<script[^\u2800]+?</script>" nil t)
                                        (replace-match ""))
                                      (goto-char (point-min))
                                      (while (re-search-forward "<style[^\u2800]+?</style>" nil t)
                                        (replace-match ""))
                                      (libxml-parse-html-region (point-min) (point-max))))))
                         (meta (delq nil
                                     (mapcar
                                      (lambda (tag)
                                        (when (eq 'meta (car tag))
                                          (cons (or (cdr (assoc 'name (cadr tag)))
                                                    (cdr (assoc 'property (cadr tag))))
                                                (cdr (assoc 'content (cadr tag))))))
                                      head-data))))
                    (let ((title (or (cdr (assoc "og:title" meta))
                                     (cdr (assoc "twitter:title" meta))
                                     (nth 2 (assq 'title head-data))))
                          (description (or (cdr (assoc "og:description" meta))
                                           (cdr (assoc "twitter:description" meta))
                                           (cdr (assoc "description" meta))))
                          (image (or (cdr (assoc "og:image" meta))
                                     (cdr (assoc "twitter:image" meta)))))
                      (when image
                        (setq image (replace-regexp-in-string
                                     "^/" (concat "https://" (replace-regexp-in-string "//\\([^/]+\\)/?.*" "\\1" url) "/")
                                     (replace-regexp-in-string
                                      "^//" "https://"
                                      image))))
                      (list :title title :description description :image image))))
                 org-url-unfurl-metadata--cache)))))
#+end_src

*** LaTeX export

#+call: confpkg("ox-latex", after="ox-latex")

**** Compiling

By default Org uses ~pdflatex~ \times 3 + ~bibtex~. This simply won't do in our
modern world. ~latexmk~ + ~biber~ (which is used automatically with ~latexmk~) is a
simply superior combination.

#+begin_src emacs-lisp
;; org-latex-compilers = ("pdflatex" "xelatex" "lualatex"), which are the possible values for %latex
(setq org-latex-pdf-process '("LC_ALL=en_US.UTF-8 latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f"))
#+end_src

While ~org-latex-pdf-process~ does support a function, and we could use that
instead, this would no longer use the log buffer --- it's a bit blind, you give
it the file name and expect it to do its thing.

The default values of ~org-latex-compilers~ is given in commented form to see how
~org-latex-pdf-process~ works with them.

While the ~-%latex~ above is slightly hacky (~-pdflatex~ expects to be given a
value) it allows us to leave ~org-latex-compilers~ unmodified.
This is nice in case I open an org file that uses =#+LATEX_COMPILER= for example,
it should still work.

**** Chameleon --- aka. match theme

#+call: confpkg("!Pkg ox-chameleon")

Once I had the idea of having the look of the LaTeX document produced match the
current Emacs theme, I was enraptured. The result is the pseudo-class ~chameleon~,
which I have implemented in the package =ox-chameleon=.

#+begin_src emacs-lisp :tangle packages.el
(package! ox-chameleon :recipe (:host github :repo "tecosaur/ox-chameleon"))
#+end_src

#+begin_src emacs-lisp
(use-package! ox-chameleon
  :after ox
  :config
  (add-to-list 'org-latex-packages-alist '("" "scrextend" nil))
  (add-to-list 'org-latex-packages-alist '("" "xcolor" nil)))
#+end_src

*** Reveal export

#+call: confpkg("!Pkg org-re-reveal", after="org-re-reveal")

By default reveal is rather nice, there are just a few tweaks that I consider a
good idea.

#+begin_src emacs-lisp
(setq org-re-reveal-theme "white"
      org-re-reveal-transition "slide"
      org-re-reveal-plugins '(markdown notes math search zoom))
#+end_src

*** ASCII export

#+call: confpkg("ox-ascii", after="ox-ascii")

To start with, why settle for ASCII when UTF-8 exists?
#+begin_src emacs-lisp
(setq org-ascii-charset 'utf-8)
#+end_src

The ASCII export is generally fairly nice. I think the main aspect that could
benefit from improvement is the appearance of LaTeX fragments. There's a nice
utility we can use to create unicode representation, which are much nicer.
It's called ~latex2text~, and it's part of the =pylatexenc= package.

With that installed, we can override the src_elisp{(org-ascii-latex-fragment)} and
src_elisp{(org-ascii-latex-environment)} functions, which are conveniently very
slim --- just extracting the content, and indenting. We'll only do something
different when =utf-8= is set.

#+begin_src emacs-lisp
(when (executable-find "latex2text")
  (after! ox-ascii
    (defvar org-ascii-convert-latex t
      "Use latex2text to convert LaTeX elements to unicode.")

    (defadvice! org-ascii-latex-environment-unicode-a (latex-environment _contents info)
      "Transcode a LATEX-ENVIRONMENT element from Org to ASCII, converting to unicode.
CONTENTS is nil.  INFO is a plist holding contextual
information."
      :override #'org-ascii-latex-environment
      (when (plist-get info :with-latex)
        (org-ascii--justify-element
         (org-remove-indentation
          (let* ((latex (org-element-property :value latex-environment))
                 (unicode (and (eq (plist-get info :ascii-charset) 'utf-8)
                               org-ascii-convert-latex
                               (doom-call-process "latex2text" "-q" "--code" latex))))
            (if (= (car unicode) 0) ; utf-8 set, and sucessfully ran latex2text
                (cdr unicode) latex)))
         latex-environment info)))

    (defadvice! org-ascii-latex-fragment-unicode-a (latex-fragment _contents info)
      "Transcode a LATEX-FRAGMENT object from Org to ASCII, converting to unicode.
CONTENTS is nil.  INFO is a plist holding contextual
information."
      :override #'org-ascii-latex-fragment
      (when (plist-get info :with-latex)
        (let* ((latex (org-element-property :value latex-fragment))
               (unicode (and (eq (plist-get info :ascii-charset) 'utf-8)
                             org-ascii-convert-latex
                             (doom-call-process "latex2text" "-q" "--code" latex))))
          (if (and unicode (= (car unicode) 0)) ; utf-8 set, and sucessfully ran latex2text
              (cdr unicode) latex))))))
#+end_src

*** Markdown Export

#+call: confpkg("ox-md", after="ox-md")

**** GFM

#+call: confpkg("!Pkg ox-gfm")

Because of the /[[https://github.com/commonmark/commonmark-spec/wiki/markdown-flavors][lovely variety in markdown implementations]]/ there isn't actually
such a thing a standard table spec ... or standard anything really. Because
~org-md~ is a goody-two-shoes, it just uses HTML for all these non-standardised
elements (a lot of them). So ~ox-gfm~ is handy for exporting markdown with all the
features that GitHub has.

#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! ox-gfm
  :recipe
  (:host github
   :repo "larstvei/ox-gfm"))
#+end_src

#+begin_src emacs-lisp
(use-package! ox-gfm
  :after ox)
#+end_src

**** Character substitutions

When I want to paste exported markdown somewhere, it can be preferable
to have unicode characters for =---= etc. instead of =&#x2014;=.

To accomplish this, we just need to locally rebind the alist which provides
these substitution.

#+begin_src emacs-lisp
(defadvice! org-md-plain-text-unicode-a (orig-fn text info)
  "Locally rebind `org-html-special-string-regexps'"
  :around #'org-md-plain-text
  (let ((org-html-special-string-regexps
         '(("\\\\-" . "-")
           ("---\\([^-]\\|$\\)" . "â\\1")
           ("--\\([^-]\\|$\\)" . "â\\1")
           ("\\.\\.\\." . "â¦")
           ("<->" . "â·")
           ("->" . "â")
           ("<-" . "â"))))
    (funcall orig-fn text (plist-put info :with-smart-quotes nil))))
#+end_src

In the future, I may want to check =info= to only have this active when =ox-gfm= is
being used.

Another worthwhile consideration is LaTeX formatting. It seems most Markdown
parsers are fixated on TeX-style syntax (=$= and =$$=). As unfortunate as this is,
it's probably best to accommodate them, for the sake of decent rendering.

=ox-md= doesn't provide any transcoders for this, so we'll have to whip up our own
and push them onto the =md= transcoders alist.

#+begin_src emacs-lisp
(after! ox-md
  (defun org-md-latex-fragment (latex-fragment _contents info)
    "Transcode a LATEX-FRAGMENT object from Org to Markdown."
    (let ((frag (org-element-property :value latex-fragment)))
      (cond
       ((string-match-p "^\\\\(" frag)
        (concat "$" (substring frag 2 -2) "$"))
       ((string-match-p "^\\\\\\[" frag)
        (concat "$$" (substring frag 2 -2) "$$"))
       (t (message "unrecognised fragment: %s" frag)
          frag))))

  (defun org-md-latex-environment (latex-environment contents info)
    "Transcode a LATEX-ENVIRONMENT object from Org to Markdown."
    (concat "$$\n"
            (org-html-latex-environment latex-environment contents info)
            "$$\n"))

  (defun org-utf8-entity (entity _contents _info)
    "Transcode an ENTITY object from Org to utf-8.
CONTENTS are the definition itself.  INFO is a plist holding
contextual information."
    (org-element-property :utf-8 entity))

  ;; We can't let this be immediately parsed and evaluated,
  ;; because eager macro-expansion tries to call as-of-yet
  ;; undefined functions.
  ;; NOTE in the near future this shouldn't be required
  (eval
   '(dolist (extra-transcoder
             '((latex-fragment . org-md-latex-fragment)
               (latex-environment . org-md-latex-environment)
               (entity . org-utf8-entity)))
      (unless (member extra-transcoder (org-export-backend-transcoders
                                        (org-export-get-backend 'md)))
        (push extra-transcoder (org-export-backend-transcoders
                                (org-export-get-backend 'md)))))))
#+end_src

*** Babel

#+call: confpkg("Org Babel")

Doom lazy-loads babel languages, with is lovely.
It also pulls in [[https://github.com/astahlman/ob-async][ob-async]], which is nice, but it would be even better if it was
used by default.

There are two caveats to =ob-async=:
1. It does not support =:session=
   + So, we don't want =:async= used when =:session= is set
2. It adds a fixed delay to execution
   + This is undesirable in a number of cases, for example it's generally
     unwanted with =emacs-lisp= code
   + As such, I also introduce a async language blacklist to control when it's
     automatically enabled

Due to the nuance in the desired behaviour, instead of just adding =:async= to
~org-babel-default-header-args~, I advice ~org-babel-get-src-block-info~ to add
=:async= intelligently. As an escape hatch, it also recognises =:sync= as an
indication that =:async= should not be added.

I did originally have this enabled for everything except for =emacs-lisp= and
=LaTeX= (there were weird issues), but this added  a ~3s "startup" cost to every
src block evaluation, which was a bit of a pain. Since =:async= can be added
easily with =#+properties=, I've turned this behaviour from a blacklist to a
whitelist.

#+begin_src emacs-lisp
(add-transient-hook! #'org-babel-execute-src-block
  (require 'ob-async))

(defvar org-babel-auto-async-languages '()
  "Babel languages which should be executed asyncronously by default.")

(defadvice! org-babel-get-src-block-info-eager-async-a (orig-fn &optional light datum)
  "Eagarly add an :async parameter to the src information, unless it seems problematic.
This only acts o languages in `org-babel-auto-async-languages'.
Not added when either:
+ session is not \"none\"
+ :sync is set"
  :around #'org-babel-get-src-block-info
  (let ((result (funcall orig-fn light datum)))
    (when (and (string= "none" (cdr (assoc :session (caddr result))))
               (member (car result) org-babel-auto-async-languages)
               (not (assoc :async (caddr result))) ; don't duplicate
               (not (assoc :sync (caddr result))))
      (push '(:async) (caddr result)))
    result))
#+end_src

** LaTeX

#+call: confpkg()

*** Compilation

#+begin_src emacs-lisp
(setq TeX-save-query nil
      TeX-show-compilation t
      TeX-command-extra-options "-shell-escape")
(after! latex
  (add-to-list 'TeX-command-list '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t)))
#+end_src

For viewing the PDF, we want to use ~pdf-tools~ viewer.
#+begin_src emacs-lisp
(setq +latex-viewers '(pdf-tools zathura evince okular skim sumatrapdf firefox))
#+end_src

*** Editor visuals

Let's enhance ~TeX-fold-math~ a bit
#+begin_src emacs-lisp
(after! latex
  (setcar (assoc "â" LaTeX-fold-math-spec-list) "â")) ;; make \star bigger

(setq TeX-fold-math-spec-list
      `(;; missing/better symbols
        ("â¤" ("le"))
        ("â¥" ("ge"))
        ("â " ("ne"))
        ;; convenience shorts -- these don't work nicely ATM
        ;; ("â¹" ("left"))
        ;; ("âº" ("right"))
        ;; private macros
        ("â" ("RR"))
        ("â" ("NN"))
        ("â¤" ("ZZ"))
        ("â" ("QQ"))
        ("â" ("CC"))
        ("â" ("PP"))
        ("â" ("HH"))
        ("ð¼" ("EE"))
        ("ð" ("dd"))
        ;; known commands
        ("" ("phantom"))
        (,(lambda (num den) (if (and (TeX-string-single-token-p num) (TeX-string-single-token-p den))
                                (concat num "ï¼" den)
                              (concat "âª" num "ï¼" den "â«"))) ("frac"))
        (,(lambda (arg) (concat "â" (TeX-fold-parenthesize-as-necessary arg))) ("sqrt"))
        (,(lambda (arg) (concat "â­¡" (TeX-fold-parenthesize-as-necessary arg))) ("vec"))
        ("â{1}â" ("text"))
        ;; private commands
        ("|{1}|" ("abs"))
        ("â{1}â" ("norm"))
        ("â{1}â" ("floor"))
        ("â{1}â" ("ceil"))
        ("â{1}â" ("round"))
        ("ð{1}/ð{2}" ("dv"))
        ("â{1}/â{2}" ("pdv"))
        ;; fancification
        ("{1}" ("mathrm"))
        (,(lambda (word) (string-offset-roman-chars 119743 word)) ("mathbf"))
        (,(lambda (word) (string-offset-roman-chars 119951 word)) ("mathcal"))
        (,(lambda (word) (string-offset-roman-chars 120003 word)) ("mathfrak"))
        (,(lambda (word) (string-offset-roman-chars 120055 word)) ("mathbb"))
        (,(lambda (word) (string-offset-roman-chars 120159 word)) ("mathsf"))
        (,(lambda (word) (string-offset-roman-chars 120367 word)) ("mathtt"))
        )
      TeX-fold-macro-spec-list
      '(
        ;; as the defaults
        ("[f]" ("footnote" "marginpar"))
        ("[c]" ("cite"))
        ("[l]" ("label"))
        ("[r]" ("ref" "pageref" "eqref"))
        ("[i]" ("index" "glossary"))
        ("..." ("dots"))
        ("{1}" ("emph" "textit" "textsl" "textmd" "textrm" "textsf" "texttt"
                "textbf" "textsc" "textup"))
        ;; tweaked defaults
        ("Â©" ("copyright"))
        ("Â®" ("textregistered"))
        ("â¢"  ("texttrademark"))
        ("[1]:||âº" ("item"))
        ("â¡â¡â{1}" ("part" "part*"))
        ("â¡â{1}" ("chapter" "chapter*"))
        ("Â§â{1}" ("section" "section*"))
        ("Â§Â§â{1}" ("subsection" "subsection*"))
        ("Â§Â§Â§â{1}" ("subsubsection" "subsubsection*"))
        ("Â¶â{1}" ("paragraph" "paragraph*"))
        ("Â¶Â¶â{1}" ("subparagraph" "subparagraph*"))
        ;; extra
        ("â¬â{1}" ("begin"))
        ("â¬â{1}" ("end"))
        ))

(defun string-offset-roman-chars (offset word)
  "Shift the codepoint of each character in WORD by OFFSET with an extra -6 shift if the letter is lowercase"
  (apply 'string
         (mapcar (lambda (c)
                   (string-offset-apply-roman-char-exceptions
                    (+ (if (>= c 97) (- c 6) c) offset)))
                 word)))

(defvar string-offset-roman-char-exceptions
  '(;; lowercase serif
    (119892 .  8462) ; â
    ;; lowercase caligraphic
    (119994 . 8495) ; â¯
    (119996 . 8458) ; â
    (120004 . 8500) ; â´
    ;; caligraphic
    (119965 . 8492) ; â¬
    (119968 . 8496) ; â°
    (119969 . 8497) ; â±
    (119971 . 8459) ; â
    (119972 . 8464) ; â
    (119975 . 8466) ; â
    (119976 . 8499) ; â³
    (119981 . 8475) ; â
    ;; fraktur
    (120070 . 8493) ; â­
    (120075 . 8460) ; â
    (120076 . 8465) ; â
    (120085 . 8476) ; â
    (120092 . 8488) ; â¨
    ;; blackboard
    (120122 . 8450) ; â
    (120127 . 8461) ; â
    (120133 . 8469) ; â
    (120135 . 8473) ; â
    (120136 . 8474) ; â
    (120137 . 8477) ; â
    (120145 . 8484) ; â¤
    )
  "An alist of deceptive codepoints, and then where the glyph actually resides.")

(defun string-offset-apply-roman-char-exceptions (char)
  "Sometimes the codepoint doesn't contain the char you expect.
Such special cases should be remapped to another value, as given in `string-offset-roman-char-exceptions'."
  (if (assoc char string-offset-roman-char-exceptions)
      (cdr (assoc char string-offset-roman-char-exceptions))
    char))

(defun TeX-fold-parenthesize-as-necessary (tokens &optional suppress-left suppress-right)
  "Add âª â« parenthesis as if multiple LaTeX tokens appear to be present"
  (if (TeX-string-single-token-p tokens) tokens
    (concat (if suppress-left "" "âª")
            tokens
            (if suppress-right "" "â«"))))

(defun TeX-string-single-token-p (teststring)
  "Return t if TESTSTRING appears to be a single token, nil otherwise"
  (if (string-match-p "^\\\\?\\w+$" teststring) t nil))
#+end_src

Some local keybindings to make life a bit easier
#+begin_src emacs-lisp
(after! tex
  (map!
   :map LaTeX-mode-map
   :ei [C-return] #'LaTeX-insert-item)
  (setq TeX-electric-math '("\\(" . "")))
#+end_src

Maths deliminators can be de-emphasised a bit
#+begin_src emacs-lisp
;; Making \( \) less visible
(defface unimportant-latex-face
  '((t :inherit font-lock-comment-face :weight extra-light))
  "Face used to make \\(\\), \\[\\] less visible."
  :group 'LaTeX-math)

(font-lock-add-keywords
 'latex-mode
 `(("\\\\[]()[]" 0 'unimportant-latex-face prepend))
 'end)

;; (font-lock-add-keywords
;;  'latex-mode
;;  '(("\\\\[[:word:]]+" 0 'font-lock-keyword-face prepend))
;;  'end)
#+end_src

And enable shell escape for the preview
#+begin_src emacs-lisp
(setq preview-LaTeX-command '("%`%l \"\\nonstopmode\\nofiles\
\\PassOptionsToPackage{" ("," . preview-required-option-list) "}{preview}\
\\AtBeginDocument{\\ifx\\ifPreview\\undefined"
preview-default-preamble "\\fi}\"%' \"\\detokenize{\" %t \"}\""))
#+end_src

*** Math input
**** CDLaTeX

The symbols and modifies are very nice by default, but could do with a bit of
fleshing out. Let's change the prefix to a key which is similarly rarely used,
but more convenient, like =;=.
#+begin_src emacs-lisp
(after! cdlatex
  (setq cdlatex-env-alist
        '(("bmatrix" "\\begin{bmatrix}\n?\n\\end{bmatrix}" nil)
          ("equation*" "\\begin{equation*}\n?\n\\end{equation*}" nil)))
  (setq ;; cdlatex-math-symbol-prefix ?\; ;; doesn't work at the moment :(
   cdlatex-math-symbol-alist
   '( ;; adding missing functions to 3rd level symbols
     (?_    ("\\downarrow"  ""           "\\inf"))
     (?2    ("^2"           "\\sqrt{?}"     ""     ))
     (?3    ("^3"           "\\sqrt[3]{?}"  ""     ))
     (?^    ("\\uparrow"    ""           "\\sup"))
     (?k    ("\\kappa"      ""           "\\ker"))
     (?m    ("\\mu"         ""           "\\lim"))
     (?c    (""             "\\circ"     "\\cos"))
     (?d    ("\\delta"      "\\partial"  "\\dim"))
     (?D    ("\\Delta"      "\\nabla"    "\\deg"))
     ;; no idea why \Phi isnt on 'F' in first place, \phi is on 'f'.
     (?F    ("\\Phi"))
     ;; now just convenience
     (?.    ("\\cdot" "\\dots"))
     (?:    ("\\vdots" "\\ddots"))
     (?*    ("\\times" "\\star" "\\ast")))
   cdlatex-math-modify-alist
   '( ;; my own stuff
     (?B    "\\mathbb"        nil          t    nil  nil)
     (?a    "\\abs"           nil          t    nil  nil))))
#+end_src

**** LAAS

#+call: confpkg("!Pkg LAAS")

This makes use of =aas= (/Auto Activating Snippets/) for CDLaTeX-like symbol input.

#+begin_src emacs-lisp :tangle packages.el
(package! laas :recipe (:host github :repo "tecosaur/LaTeX-auto-activating-snippets"))
#+end_src

#+begin_src emacs-lisp
(use-package! laas
  :hook (LaTeX-mode . laas-mode)
  :config
  (defun laas-tex-fold-maybe ()
    (unless (equal "/" aas-transient-snippet-key)
      (+latex-fold-last-macro-a)))
  (add-hook 'aas-post-snippet-expand-hook #'laas-tex-fold-maybe))
#+end_src

*** SyncTeX

#+begin_src emacs-lisp
(after! tex
  (add-to-list 'TeX-view-program-list '("Zathura" "zathura %o"))
  (add-to-list 'TeX-view-program-selection '(output-pdf "Zathura")))
#+end_src

*** Fixes

In case of Emacs28,
#+begin_src emacs-lisp
(when EMACS28+
  (add-hook 'latex-mode-hook #'TeX-latex-mode))
#+end_src

** Markdown

#+call: confpkg()

Most of the time when I write markdown, it's going into some app/website which
will do it's own line wrapping, hence we /only/ want to use visual line wrapping. No hard stuff.
#+begin_src emacs-lisp
(add-hook! (gfm-mode markdown-mode) #'visual-line-mode #'turn-off-auto-fill)
#+end_src

Since markdown is often seen as rendered HTML, let's try to somewhat mirror the
style or markdown renderers.

Most markdown renders seem to make the first three headings levels larger than
normal text, the first two much so. Then the fourth level tends to be the same
as body text, while the fifth and sixth are (increasingly) smaller, with the
sixth greyed out. Since the sixth level is so small, I'll turn up the boldness a notch.
#+begin_src emacs-lisp
(custom-set-faces!
  '(markdown-header-face-1 :height 1.25 :weight extra-bold :inherit markdown-header-face)
  '(markdown-header-face-2 :height 1.15 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-3 :height 1.08 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-4 :height 1.00 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-5 :height 0.90 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-6 :height 0.75 :weight extra-bold :inherit markdown-header-face))
#+end_src
